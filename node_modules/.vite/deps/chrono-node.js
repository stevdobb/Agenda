import {
  __export,
  __publicField
} from "./chunk-UVKRO5ER.js";

// node_modules/chrono-node/dist/esm/locales/en/index.js
var en_exports = {};
__export(en_exports, {
  Chrono: () => Chrono,
  GB: () => GB,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual,
  configuration: () => configuration,
  parse: () => parse,
  parseDate: () => parseDate,
  strict: () => strict
});

// node_modules/chrono-node/dist/esm/types.js
var Meridiem;
(function(Meridiem2) {
  Meridiem2[Meridiem2["AM"] = 0] = "AM";
  Meridiem2[Meridiem2["PM"] = 1] = "PM";
})(Meridiem || (Meridiem = {}));
var Weekday;
(function(Weekday2) {
  Weekday2[Weekday2["SUNDAY"] = 0] = "SUNDAY";
  Weekday2[Weekday2["MONDAY"] = 1] = "MONDAY";
  Weekday2[Weekday2["TUESDAY"] = 2] = "TUESDAY";
  Weekday2[Weekday2["WEDNESDAY"] = 3] = "WEDNESDAY";
  Weekday2[Weekday2["THURSDAY"] = 4] = "THURSDAY";
  Weekday2[Weekday2["FRIDAY"] = 5] = "FRIDAY";
  Weekday2[Weekday2["SATURDAY"] = 6] = "SATURDAY";
})(Weekday || (Weekday = {}));
var Month;
(function(Month2) {
  Month2[Month2["JANUARY"] = 1] = "JANUARY";
  Month2[Month2["FEBRUARY"] = 2] = "FEBRUARY";
  Month2[Month2["MARCH"] = 3] = "MARCH";
  Month2[Month2["APRIL"] = 4] = "APRIL";
  Month2[Month2["MAY"] = 5] = "MAY";
  Month2[Month2["JUNE"] = 6] = "JUNE";
  Month2[Month2["JULY"] = 7] = "JULY";
  Month2[Month2["AUGUST"] = 8] = "AUGUST";
  Month2[Month2["SEPTEMBER"] = 9] = "SEPTEMBER";
  Month2[Month2["OCTOBER"] = 10] = "OCTOBER";
  Month2[Month2["NOVEMBER"] = 11] = "NOVEMBER";
  Month2[Month2["DECEMBER"] = 12] = "DECEMBER";
})(Month || (Month = {}));

// node_modules/chrono-node/dist/esm/utils/dates.js
function assignSimilarDate(component, target) {
  component.assign("day", target.getDate());
  component.assign("month", target.getMonth() + 1);
  component.assign("year", target.getFullYear());
}
function assignSimilarTime(component, target) {
  component.assign("hour", target.getHours());
  component.assign("minute", target.getMinutes());
  component.assign("second", target.getSeconds());
  component.assign("millisecond", target.getMilliseconds());
  component.assign("meridiem", target.getHours() < 12 ? Meridiem.AM : Meridiem.PM);
}
function implySimilarDate(component, target) {
  component.imply("day", target.getDate());
  component.imply("month", target.getMonth() + 1);
  component.imply("year", target.getFullYear());
}
function implySimilarTime(component, target) {
  component.imply("hour", target.getHours());
  component.imply("minute", target.getMinutes());
  component.imply("second", target.getSeconds());
  component.imply("millisecond", target.getMilliseconds());
  component.imply("meridiem", target.getHours() < 12 ? Meridiem.AM : Meridiem.PM);
}

// node_modules/chrono-node/dist/esm/timezone.js
var TIMEZONE_ABBR_MAP = {
  ACDT: 630,
  ACST: 570,
  ADT: -180,
  AEDT: 660,
  AEST: 600,
  AFT: 270,
  AKDT: -480,
  AKST: -540,
  ALMT: 360,
  AMST: -180,
  AMT: -240,
  ANAST: 720,
  ANAT: 720,
  AQTT: 300,
  ART: -180,
  AST: -240,
  AWDT: 540,
  AWST: 480,
  AZOST: 0,
  AZOT: -60,
  AZST: 300,
  AZT: 240,
  BNT: 480,
  BOT: -240,
  BRST: -120,
  BRT: -180,
  BST: 60,
  BTT: 360,
  CAST: 480,
  CAT: 120,
  CCT: 390,
  CDT: -300,
  CEST: 120,
  CET: {
    timezoneOffsetDuringDst: 2 * 60,
    timezoneOffsetNonDst: 60,
    dstStart: (year3) => getLastWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2),
    dstEnd: (year3) => getLastWeekdayOfMonth(year3, Month.OCTOBER, Weekday.SUNDAY, 3)
  },
  CHADT: 825,
  CHAST: 765,
  CKT: -600,
  CLST: -180,
  CLT: -240,
  COT: -300,
  CST: -360,
  CT: {
    timezoneOffsetDuringDst: -5 * 60,
    timezoneOffsetNonDst: -6 * 60,
    dstStart: (year3) => getNthWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2, 2),
    dstEnd: (year3) => getNthWeekdayOfMonth(year3, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
  },
  CVT: -60,
  CXT: 420,
  ChST: 600,
  DAVT: 420,
  EASST: -300,
  EAST: -360,
  EAT: 180,
  ECT: -300,
  EDT: -240,
  EEST: 180,
  EET: 120,
  EGST: 0,
  EGT: -60,
  EST: -300,
  ET: {
    timezoneOffsetDuringDst: -4 * 60,
    timezoneOffsetNonDst: -5 * 60,
    dstStart: (year3) => getNthWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2, 2),
    dstEnd: (year3) => getNthWeekdayOfMonth(year3, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
  },
  FJST: 780,
  FJT: 720,
  FKST: -180,
  FKT: -240,
  FNT: -120,
  GALT: -360,
  GAMT: -540,
  GET: 240,
  GFT: -180,
  GILT: 720,
  GMT: 0,
  GST: 240,
  GYT: -240,
  HAA: -180,
  HAC: -300,
  HADT: -540,
  HAE: -240,
  HAP: -420,
  HAR: -360,
  HAST: -600,
  HAT: -90,
  HAY: -480,
  HKT: 480,
  HLV: -210,
  HNA: -240,
  HNC: -360,
  HNE: -300,
  HNP: -480,
  HNR: -420,
  HNT: -150,
  HNY: -540,
  HOVT: 420,
  ICT: 420,
  IDT: 180,
  IOT: 360,
  IRDT: 270,
  IRKST: 540,
  IRKT: 540,
  IRST: 210,
  IST: 330,
  JST: 540,
  KGT: 360,
  KRAST: 480,
  KRAT: 480,
  KST: 540,
  KUYT: 240,
  LHDT: 660,
  LHST: 630,
  LINT: 840,
  MAGST: 720,
  MAGT: 720,
  MART: -510,
  MAWT: 300,
  MDT: -360,
  MESZ: 120,
  MEZ: 60,
  MHT: 720,
  MMT: 390,
  MSD: 240,
  MSK: 180,
  MST: -420,
  MT: {
    timezoneOffsetDuringDst: -6 * 60,
    timezoneOffsetNonDst: -7 * 60,
    dstStart: (year3) => getNthWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2, 2),
    dstEnd: (year3) => getNthWeekdayOfMonth(year3, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
  },
  MUT: 240,
  MVT: 300,
  MYT: 480,
  NCT: 660,
  NDT: -90,
  NFT: 690,
  NOVST: 420,
  NOVT: 360,
  NPT: 345,
  NST: -150,
  NUT: -660,
  NZDT: 780,
  NZST: 720,
  OMSST: 420,
  OMST: 420,
  PDT: -420,
  PET: -300,
  PETST: 720,
  PETT: 720,
  PGT: 600,
  PHOT: 780,
  PHT: 480,
  PKT: 300,
  PMDT: -120,
  PMST: -180,
  PONT: 660,
  PST: -480,
  PT: {
    timezoneOffsetDuringDst: -7 * 60,
    timezoneOffsetNonDst: -8 * 60,
    dstStart: (year3) => getNthWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2, 2),
    dstEnd: (year3) => getNthWeekdayOfMonth(year3, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
  },
  PWT: 540,
  PYST: -180,
  PYT: -240,
  RET: 240,
  SAMT: 240,
  SAST: 120,
  SBT: 660,
  SCT: 240,
  SGT: 480,
  SRT: -180,
  SST: -660,
  TAHT: -600,
  TFT: 300,
  TJT: 300,
  TKT: 780,
  TLT: 540,
  TMT: 300,
  TVT: 720,
  ULAT: 480,
  UTC: 0,
  UYST: -120,
  UYT: -180,
  UZT: 300,
  VET: -210,
  VLAST: 660,
  VLAT: 660,
  VUT: 660,
  WAST: 120,
  WAT: 60,
  WEST: 60,
  WESZ: 60,
  WET: 0,
  WEZ: 0,
  WFT: 720,
  WGST: -120,
  WGT: -180,
  WIB: 420,
  WIT: 540,
  WITA: 480,
  WST: 780,
  WT: 0,
  YAKST: 600,
  YAKT: 600,
  YAPT: 600,
  YEKST: 360,
  YEKT: 360
};
function getNthWeekdayOfMonth(year3, month, weekday, n, hour = 0) {
  let dayOfMonth = 0;
  let i = 0;
  while (i < n) {
    dayOfMonth++;
    const date = new Date(year3, month - 1, dayOfMonth);
    if (date.getDay() === weekday)
      i++;
  }
  return new Date(year3, month - 1, dayOfMonth, hour);
}
function getLastWeekdayOfMonth(year3, month, weekday, hour = 0) {
  const oneIndexedWeekday = weekday === 0 ? 7 : weekday;
  const date = new Date(year3, month - 1 + 1, 1, 12);
  const firstWeekdayNextMonth = date.getDay() === 0 ? 7 : date.getDay();
  let dayDiff;
  if (firstWeekdayNextMonth === oneIndexedWeekday)
    dayDiff = 7;
  else if (firstWeekdayNextMonth < oneIndexedWeekday)
    dayDiff = 7 + firstWeekdayNextMonth - oneIndexedWeekday;
  else
    dayDiff = firstWeekdayNextMonth - oneIndexedWeekday;
  date.setDate(date.getDate() - dayDiff);
  return new Date(year3, month - 1, date.getDate(), hour);
}
function toTimezoneOffset(timezoneInput, date, timezoneOverrides = {}) {
  if (timezoneInput == null) {
    return null;
  }
  if (typeof timezoneInput === "number") {
    return timezoneInput;
  }
  const matchedTimezone = timezoneOverrides[timezoneInput] ?? TIMEZONE_ABBR_MAP[timezoneInput];
  if (matchedTimezone == null) {
    return null;
  }
  if (typeof matchedTimezone == "number") {
    return matchedTimezone;
  }
  if (date == null) {
    return null;
  }
  if (date > matchedTimezone.dstStart(date.getFullYear()) && !(date > matchedTimezone.dstEnd(date.getFullYear()))) {
    return matchedTimezone.timezoneOffsetDuringDst;
  }
  return matchedTimezone.timezoneOffsetNonDst;
}

// node_modules/chrono-node/dist/esm/calculation/duration.js
var EmptyDuration = {
  day: 0,
  second: 0,
  millisecond: 0
};
function addDuration(ref, duration) {
  let date = new Date(ref);
  if (duration["y"]) {
    duration["year"] = duration["y"];
    delete duration["y"];
  }
  if (duration["mo"]) {
    duration["month"] = duration["mo"];
    delete duration["mo"];
  }
  if (duration["M"]) {
    duration["month"] = duration["M"];
    delete duration["M"];
  }
  if (duration["w"]) {
    duration["week"] = duration["w"];
    delete duration["w"];
  }
  if (duration["d"]) {
    duration["day"] = duration["d"];
    delete duration["d"];
  }
  if (duration["h"]) {
    duration["hour"] = duration["h"];
    delete duration["h"];
  }
  if (duration["m"]) {
    duration["minute"] = duration["m"];
    delete duration["m"];
  }
  if (duration["s"]) {
    duration["second"] = duration["s"];
    delete duration["s"];
  }
  if (duration["ms"]) {
    duration["millisecond"] = duration["ms"];
    delete duration["ms"];
  }
  if ("year" in duration) {
    const floor = Math.floor(duration["year"]);
    date.setFullYear(date.getFullYear() + floor);
    const remainingFraction = duration["year"] - floor;
    if (remainingFraction > 0) {
      duration.month = (duration == null ? void 0 : duration.month) ?? 0;
      duration.month += remainingFraction * 12;
    }
  }
  if ("quarter" in duration) {
    const floor = Math.floor(duration["quarter"]);
    date.setMonth(date.getMonth() + floor * 3);
  }
  if ("month" in duration) {
    const floor = Math.floor(duration["month"]);
    date.setMonth(date.getMonth() + floor);
    const remainingFraction = duration["month"] - floor;
    if (remainingFraction > 0) {
      duration.week = (duration == null ? void 0 : duration.week) ?? 0;
      duration.week += remainingFraction * 4;
    }
  }
  if ("week" in duration) {
    const floor = Math.floor(duration["week"]);
    date.setDate(date.getDate() + floor * 7);
    const remainingFraction = duration["week"] - floor;
    if (remainingFraction > 0) {
      duration.day = (duration == null ? void 0 : duration.day) ?? 0;
      duration.day += Math.round(remainingFraction * 7);
    }
  }
  if ("day" in duration) {
    const floor = Math.floor(duration["day"]);
    date.setDate(date.getDate() + floor);
    const remainingFraction = duration["day"] - floor;
    if (remainingFraction > 0) {
      duration.hour = (duration == null ? void 0 : duration.hour) ?? 0;
      duration.hour += Math.round(remainingFraction * 24);
    }
  }
  if ("hour" in duration) {
    const floor = Math.floor(duration["hour"]);
    date.setHours(date.getHours() + floor);
    const remainingFraction = duration["hour"] - floor;
    if (remainingFraction > 0) {
      duration.minute = (duration == null ? void 0 : duration.minute) ?? 0;
      duration.minute += Math.round(remainingFraction * 60);
    }
  }
  if ("minute" in duration) {
    const floor = Math.floor(duration["minute"]);
    date.setMinutes(date.getMinutes() + floor);
    const remainingFraction = duration["minute"] - floor;
    if (remainingFraction > 0) {
      duration.second = (duration == null ? void 0 : duration.second) ?? 0;
      duration.second += Math.round(remainingFraction * 60);
    }
  }
  if ("second" in duration) {
    const floor = Math.floor(duration["second"]);
    date.setSeconds(date.getSeconds() + floor);
    const remainingFraction = duration["second"] - floor;
    if (remainingFraction > 0) {
      duration.millisecond = (duration == null ? void 0 : duration.millisecond) ?? 0;
      duration.millisecond += Math.round(remainingFraction * 1e3);
    }
  }
  if ("millisecond" in duration) {
    const floor = Math.floor(duration["millisecond"]);
    date.setMilliseconds(date.getMilliseconds() + floor);
  }
  return date;
}
function reverseDuration(duration) {
  const reversed = {};
  for (const key in duration) {
    reversed[key] = -duration[key];
  }
  return reversed;
}

// node_modules/chrono-node/dist/esm/results.js
var ReferenceWithTimezone = class _ReferenceWithTimezone {
  constructor(instant, timezoneOffset) {
    __publicField(this, "instant");
    __publicField(this, "timezoneOffset");
    this.instant = instant ?? /* @__PURE__ */ new Date();
    this.timezoneOffset = timezoneOffset ?? null;
  }
  static fromDate(date) {
    return new _ReferenceWithTimezone(date);
  }
  static fromInput(input, timezoneOverrides) {
    if (input instanceof Date) {
      return _ReferenceWithTimezone.fromDate(input);
    }
    const instant = (input == null ? void 0 : input.instant) ?? /* @__PURE__ */ new Date();
    const timezoneOffset = toTimezoneOffset(input == null ? void 0 : input.timezone, instant, timezoneOverrides);
    return new _ReferenceWithTimezone(instant, timezoneOffset);
  }
  getDateWithAdjustedTimezone() {
    const date = new Date(this.instant);
    if (this.timezoneOffset !== null) {
      date.setMinutes(date.getMinutes() - this.getSystemTimezoneAdjustmentMinute(this.instant));
    }
    return date;
  }
  getSystemTimezoneAdjustmentMinute(date, overrideTimezoneOffset) {
    if (!date || date.getTime() < 0) {
      date = /* @__PURE__ */ new Date();
    }
    const currentTimezoneOffset = -date.getTimezoneOffset();
    const targetTimezoneOffset = overrideTimezoneOffset ?? this.timezoneOffset ?? currentTimezoneOffset;
    return currentTimezoneOffset - targetTimezoneOffset;
  }
  getTimezoneOffset() {
    return this.timezoneOffset ?? -this.instant.getTimezoneOffset();
  }
};
var ParsingComponents = class _ParsingComponents {
  constructor(reference, knownComponents) {
    __publicField(this, "knownValues");
    __publicField(this, "impliedValues");
    __publicField(this, "reference");
    __publicField(this, "_tags", /* @__PURE__ */ new Set());
    this.reference = reference;
    this.knownValues = {};
    this.impliedValues = {};
    if (knownComponents) {
      for (const key in knownComponents) {
        this.knownValues[key] = knownComponents[key];
      }
    }
    const date = reference.getDateWithAdjustedTimezone();
    this.imply("day", date.getDate());
    this.imply("month", date.getMonth() + 1);
    this.imply("year", date.getFullYear());
    this.imply("hour", 12);
    this.imply("minute", 0);
    this.imply("second", 0);
    this.imply("millisecond", 0);
  }
  static createRelativeFromReference(reference, duration = EmptyDuration) {
    let date = addDuration(reference.getDateWithAdjustedTimezone(), duration);
    const components = new _ParsingComponents(reference);
    components.addTag("result/relativeDate");
    if ("hour" in duration || "minute" in duration || "second" in duration || "millisecond" in duration) {
      components.addTag("result/relativeDateAndTime");
      assignSimilarTime(components, date);
      assignSimilarDate(components, date);
      components.assign("timezoneOffset", reference.getTimezoneOffset());
    } else {
      implySimilarTime(components, date);
      components.imply("timezoneOffset", reference.getTimezoneOffset());
      if ("day" in duration) {
        components.assign("day", date.getDate());
        components.assign("month", date.getMonth() + 1);
        components.assign("year", date.getFullYear());
        components.assign("weekday", date.getDay());
      } else if ("week" in duration) {
        components.assign("day", date.getDate());
        components.assign("month", date.getMonth() + 1);
        components.assign("year", date.getFullYear());
        components.imply("weekday", date.getDay());
      } else {
        components.imply("day", date.getDate());
        if ("month" in duration) {
          components.assign("month", date.getMonth() + 1);
          components.assign("year", date.getFullYear());
        } else {
          components.imply("month", date.getMonth() + 1);
          if ("year" in duration) {
            components.assign("year", date.getFullYear());
          } else {
            components.imply("year", date.getFullYear());
          }
        }
      }
    }
    return components;
  }
  get(component) {
    if (component in this.knownValues) {
      return this.knownValues[component];
    }
    if (component in this.impliedValues) {
      return this.impliedValues[component];
    }
    return null;
  }
  isCertain(component) {
    return component in this.knownValues;
  }
  getCertainComponents() {
    return Object.keys(this.knownValues);
  }
  imply(component, value) {
    if (component in this.knownValues) {
      return this;
    }
    this.impliedValues[component] = value;
    return this;
  }
  assign(component, value) {
    this.knownValues[component] = value;
    delete this.impliedValues[component];
    return this;
  }
  addDurationAsImplied(duration) {
    const currentDate = this.dateWithoutTimezoneAdjustment();
    const date = addDuration(currentDate, duration);
    if ("day" in duration || "week" in duration || "month" in duration || "year" in duration) {
      this.delete(["day", "weekday", "month", "year"]);
      this.imply("day", date.getDate());
      this.imply("weekday", date.getDay());
      this.imply("month", date.getMonth() + 1);
      this.imply("year", date.getFullYear());
    }
    if ("second" in duration || "minute" in duration || "hour" in duration) {
      this.delete(["second", "minute", "hour"]);
      this.imply("second", date.getSeconds());
      this.imply("minute", date.getMinutes());
      this.imply("hour", date.getHours());
    }
    return this;
  }
  delete(components) {
    if (typeof components === "string") {
      components = [components];
    }
    for (const component of components) {
      delete this.knownValues[component];
      delete this.impliedValues[component];
    }
  }
  clone() {
    const component = new _ParsingComponents(this.reference);
    component.knownValues = {};
    component.impliedValues = {};
    for (const key in this.knownValues) {
      component.knownValues[key] = this.knownValues[key];
    }
    for (const key in this.impliedValues) {
      component.impliedValues[key] = this.impliedValues[key];
    }
    return component;
  }
  isOnlyDate() {
    return !this.isCertain("hour") && !this.isCertain("minute") && !this.isCertain("second");
  }
  isOnlyTime() {
    return !this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month") && !this.isCertain("year");
  }
  isOnlyWeekdayComponent() {
    return this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
  }
  isDateWithUnknownYear() {
    return this.isCertain("month") && !this.isCertain("year");
  }
  isValidDate() {
    const date = this.dateWithoutTimezoneAdjustment();
    if (date.getFullYear() !== this.get("year"))
      return false;
    if (date.getMonth() !== this.get("month") - 1)
      return false;
    if (date.getDate() !== this.get("day"))
      return false;
    if (this.get("hour") != null && date.getHours() != this.get("hour"))
      return false;
    if (this.get("minute") != null && date.getMinutes() != this.get("minute"))
      return false;
    return true;
  }
  toString() {
    return `[ParsingComponents {
            tags: ${JSON.stringify(Array.from(this._tags).sort())}, 
            knownValues: ${JSON.stringify(this.knownValues)}, 
            impliedValues: ${JSON.stringify(this.impliedValues)}}, 
            reference: ${JSON.stringify(this.reference)}]`;
  }
  date() {
    const date = this.dateWithoutTimezoneAdjustment();
    const timezoneAdjustment = this.reference.getSystemTimezoneAdjustmentMinute(date, this.get("timezoneOffset"));
    return new Date(date.getTime() + timezoneAdjustment * 6e4);
  }
  addTag(tag) {
    this._tags.add(tag);
    return this;
  }
  addTags(tags) {
    for (const tag of tags) {
      this._tags.add(tag);
    }
    return this;
  }
  tags() {
    return new Set(this._tags);
  }
  dateWithoutTimezoneAdjustment() {
    const date = new Date(this.get("year"), this.get("month") - 1, this.get("day"), this.get("hour"), this.get("minute"), this.get("second"), this.get("millisecond"));
    date.setFullYear(this.get("year"));
    return date;
  }
};
var ParsingResult = class _ParsingResult {
  constructor(reference, index, text, start, end) {
    __publicField(this, "refDate");
    __publicField(this, "index");
    __publicField(this, "text");
    __publicField(this, "reference");
    __publicField(this, "start");
    __publicField(this, "end");
    this.reference = reference;
    this.refDate = reference.instant;
    this.index = index;
    this.text = text;
    this.start = start || new ParsingComponents(reference);
    this.end = end;
  }
  clone() {
    const result = new _ParsingResult(this.reference, this.index, this.text);
    result.start = this.start ? this.start.clone() : null;
    result.end = this.end ? this.end.clone() : null;
    return result;
  }
  date() {
    return this.start.date();
  }
  addTag(tag) {
    this.start.addTag(tag);
    if (this.end) {
      this.end.addTag(tag);
    }
    return this;
  }
  addTags(tags) {
    this.start.addTags(tags);
    if (this.end) {
      this.end.addTags(tags);
    }
    return this;
  }
  tags() {
    const combinedTags = new Set(this.start.tags());
    if (this.end) {
      for (const tag of this.end.tags()) {
        combinedTags.add(tag);
      }
    }
    return combinedTags;
  }
  toString() {
    const tags = Array.from(this.tags()).sort();
    return `[ParsingResult {index: ${this.index}, text: '${this.text}', tags: ${JSON.stringify(tags)} ...}]`;
  }
};

// node_modules/chrono-node/dist/esm/utils/pattern.js
function repeatedTimeunitPattern(prefix, singleTimeunitPattern, connectorPattern = "\\s{0,5},?\\s{0,5}") {
  const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\((?!\?)/g, "(?:");
  return `${prefix}${singleTimeunitPatternNoCapture}(?:${connectorPattern}${singleTimeunitPatternNoCapture}){0,10}`;
}
function extractTerms(dictionary) {
  let keys;
  if (dictionary instanceof Array) {
    keys = [...dictionary];
  } else if (dictionary instanceof Map) {
    keys = Array.from(dictionary.keys());
  } else {
    keys = Object.keys(dictionary);
  }
  return keys;
}
function matchAnyPattern(dictionary) {
  const joinedTerms = extractTerms(dictionary).sort((a, b) => b.length - a.length).join("|").replace(/\./g, "\\.");
  return `(?:${joinedTerms})`;
}

// node_modules/chrono-node/dist/esm/calculation/years.js
function findMostLikelyADYear(yearNumber) {
  if (yearNumber < 100) {
    if (yearNumber > 50) {
      yearNumber = yearNumber + 1900;
    } else {
      yearNumber = yearNumber + 2e3;
    }
  }
  return yearNumber;
}
function findYearClosestToRef(refDate, day, month) {
  let date = new Date(refDate);
  date.setMonth(month - 1);
  date.setDate(day);
  const nextYear = addDuration(date, { "year": 1 });
  const lastYear = addDuration(date, { "year": -1 });
  if (Math.abs(nextYear.getTime() - refDate.getTime()) < Math.abs(date.getTime() - refDate.getTime())) {
    date = nextYear;
  } else if (Math.abs(lastYear.getTime() - refDate.getTime()) < Math.abs(date.getTime() - refDate.getTime())) {
    date = lastYear;
  }
  return date.getFullYear();
}

// node_modules/chrono-node/dist/esm/locales/en/constants.js
var WEEKDAY_DICTIONARY = {
  sunday: 0,
  sun: 0,
  "sun.": 0,
  monday: 1,
  mon: 1,
  "mon.": 1,
  tuesday: 2,
  tue: 2,
  "tue.": 2,
  wednesday: 3,
  wed: 3,
  "wed.": 3,
  thursday: 4,
  thurs: 4,
  "thurs.": 4,
  thur: 4,
  "thur.": 4,
  thu: 4,
  "thu.": 4,
  friday: 5,
  fri: 5,
  "fri.": 5,
  saturday: 6,
  sat: 6,
  "sat.": 6
};
var FULL_MONTH_NAME_DICTIONARY = {
  january: 1,
  february: 2,
  march: 3,
  april: 4,
  may: 5,
  june: 6,
  july: 7,
  august: 8,
  september: 9,
  october: 10,
  november: 11,
  december: 12
};
var MONTH_DICTIONARY = {
  ...FULL_MONTH_NAME_DICTIONARY,
  jan: 1,
  "jan.": 1,
  feb: 2,
  "feb.": 2,
  mar: 3,
  "mar.": 3,
  apr: 4,
  "apr.": 4,
  jun: 6,
  "jun.": 6,
  jul: 7,
  "jul.": 7,
  aug: 8,
  "aug.": 8,
  sep: 9,
  "sep.": 9,
  sept: 9,
  "sept.": 9,
  oct: 10,
  "oct.": 10,
  nov: 11,
  "nov.": 11,
  dec: 12,
  "dec.": 12
};
var INTEGER_WORD_DICTIONARY = {
  one: 1,
  two: 2,
  three: 3,
  four: 4,
  five: 5,
  six: 6,
  seven: 7,
  eight: 8,
  nine: 9,
  ten: 10,
  eleven: 11,
  twelve: 12
};
var ORDINAL_WORD_DICTIONARY = {
  first: 1,
  second: 2,
  third: 3,
  fourth: 4,
  fifth: 5,
  sixth: 6,
  seventh: 7,
  eighth: 8,
  ninth: 9,
  tenth: 10,
  eleventh: 11,
  twelfth: 12,
  thirteenth: 13,
  fourteenth: 14,
  fifteenth: 15,
  sixteenth: 16,
  seventeenth: 17,
  eighteenth: 18,
  nineteenth: 19,
  twentieth: 20,
  "twenty first": 21,
  "twenty-first": 21,
  "twenty second": 22,
  "twenty-second": 22,
  "twenty third": 23,
  "twenty-third": 23,
  "twenty fourth": 24,
  "twenty-fourth": 24,
  "twenty fifth": 25,
  "twenty-fifth": 25,
  "twenty sixth": 26,
  "twenty-sixth": 26,
  "twenty seventh": 27,
  "twenty-seventh": 27,
  "twenty eighth": 28,
  "twenty-eighth": 28,
  "twenty ninth": 29,
  "twenty-ninth": 29,
  "thirtieth": 30,
  "thirty first": 31,
  "thirty-first": 31
};
var TIME_UNIT_DICTIONARY_NO_ABBR = {
  second: "second",
  seconds: "second",
  minute: "minute",
  minutes: "minute",
  hour: "hour",
  hours: "hour",
  day: "day",
  days: "day",
  week: "week",
  weeks: "week",
  month: "month",
  months: "month",
  quarter: "quarter",
  quarters: "quarter",
  year: "year",
  years: "year"
};
var TIME_UNIT_DICTIONARY = {
  s: "second",
  sec: "second",
  second: "second",
  seconds: "second",
  m: "minute",
  min: "minute",
  mins: "minute",
  minute: "minute",
  minutes: "minute",
  h: "hour",
  hr: "hour",
  hrs: "hour",
  hour: "hour",
  hours: "hour",
  d: "day",
  day: "day",
  days: "day",
  w: "week",
  week: "week",
  weeks: "week",
  mo: "month",
  mon: "month",
  mos: "month",
  month: "month",
  months: "month",
  qtr: "quarter",
  quarter: "quarter",
  quarters: "quarter",
  y: "year",
  yr: "year",
  year: "year",
  years: "year",
  ...TIME_UNIT_DICTIONARY_NO_ABBR
};
var NUMBER_PATTERN = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}an?)?|an?\\b(?:\\s{0,2}few)?|few|several|the|a?\\s{0,2}couple\\s{0,2}(?:of)?)`;
function parseNumberPattern(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY[num];
  } else if (num === "a" || num === "an" || num == "the") {
    return 1;
  } else if (num.match(/few/)) {
    return 3;
  } else if (num.match(/half/)) {
    return 0.5;
  } else if (num.match(/couple/)) {
    return 2;
  } else if (num.match(/several/)) {
    return 7;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;
function parseOrdinalNumberPattern(match) {
  let num = match.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY[num];
  }
  num = num.replace(/(?:st|nd|rd|th)$/i, "");
  return parseInt(num);
}
var YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9]|2[0-5])`;
function parseYear(match) {
  if (/BE/i.test(match)) {
    match = match.replace(/BE/i, "");
    return parseInt(match) - 543;
  }
  if (/BCE?/i.test(match)) {
    match = match.replace(/BCE?/i, "");
    return -parseInt(match);
  }
  if (/(AD|CE)/i.test(match)) {
    match = match.replace(/(AD|CE)/i, "");
    return parseInt(match);
  }
  const rawYearNumber = parseInt(match);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;
var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
var SINGLE_TIME_UNIT_NO_ABBR_PATTERN = `(${NUMBER_PATTERN})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY_NO_ABBR)})`;
var TIME_UNIT_CONNECTOR_PATTERN = `\\s{0,5},?(?:\\s*and)?\\s{0,5}`;
var TIME_UNITS_PATTERN = repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN, TIME_UNIT_CONNECTOR_PATTERN);
var TIME_UNITS_NO_ABBR_PATTERN = repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_NO_ABBR_PATTERN, TIME_UNIT_CONNECTOR_PATTERN);
function parseDuration(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
  while (match) {
    collectDateTimeFragment(fragments, match);
    remainingText = remainingText.substring(match[0].length).trim();
    match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
  }
  if (Object.keys(fragments).length == 0) {
    return null;
  }
  return fragments;
}
function collectDateTimeFragment(fragments, match) {
  if (match[0].match(/^[a-zA-Z]+$/)) {
    return;
  }
  const num = parseNumberPattern(match[1]);
  const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/common/parsers/AbstractParserWithWordBoundary.js
var AbstractParserWithWordBoundaryChecking = class {
  constructor() {
    __publicField(this, "cachedInnerPattern", null);
    __publicField(this, "cachedPattern", null);
  }
  innerPatternHasChange(context, currentInnerPattern) {
    return this.innerPattern(context) !== currentInnerPattern;
  }
  patternLeftBoundary() {
    return `(\\W|^)`;
  }
  pattern(context) {
    if (this.cachedInnerPattern) {
      if (!this.innerPatternHasChange(context, this.cachedInnerPattern)) {
        return this.cachedPattern;
      }
    }
    this.cachedInnerPattern = this.innerPattern(context);
    this.cachedPattern = new RegExp(`${this.patternLeftBoundary()}${this.cachedInnerPattern.source}`, this.cachedInnerPattern.flags);
    return this.cachedPattern;
  }
  extract(context, match) {
    const header = match[1] ?? "";
    match.index = match.index + header.length;
    match[0] = match[0].substring(header.length);
    for (let i = 2; i < match.length; i++) {
      match[i - 1] = match[i];
    }
    return this.innerExtract(context, match);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitWithinFormatParser.js
var PATTERN_WITH_OPTIONAL_PREFIX = new RegExp(`(?:(?:within|in|for)\\s*)?(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
var PATTERN_WITH_PREFIX = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
var PATTERN_WITH_PREFIX_STRICT = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\W|$)`, "i");
var ENTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMode) {
    super();
    __publicField(this, "strictMode");
    this.strictMode = strictMode;
  }
  innerPattern(context) {
    if (this.strictMode) {
      return PATTERN_WITH_PREFIX_STRICT;
    }
    return context.option.forwardDate ? PATTERN_WITH_OPTIONAL_PREFIX : PATTERN_WITH_PREFIX;
  }
  innerExtract(context, match) {
    if (match[0].match(/^for\s*the\s*\w+/)) {
      return null;
    }
    const timeUnits = parseDuration(match[1]);
    if (!timeUnits) {
      return null;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameLittleEndianParser.js
var PATTERN = new RegExp(`(?:on\\s{0,3})?(${ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:to|\\-|\\–|until|through|till)?\\s{0,3}(${ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s{0,3}(?:of)?\\s{0,3})(${matchAnyPattern(MONTH_DICTIONARY)})(?:(?:-|/|,?\\s{0,3})(${YEAR_PATTERN}(?!\\w)))?(?=\\W|$)`, "i");
var DATE_GROUP = 1;
var DATE_TO_GROUP = 2;
var MONTH_NAME_GROUP = 3;
var YEAR_GROUP = 4;
var ENMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
    const day = parseOrdinalNumberPattern(match[DATE_GROUP]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP]) {
      const yearNumber = parseYear(match[YEAR_GROUP]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP]) {
      const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameMiddleEndianParser.js
var PATTERN2 = new RegExp(`(${matchAnyPattern(MONTH_DICTIONARY)})(?:-|/|\\s*,?\\s*)(${ORDINAL_NUMBER_PATTERN})(?!\\s*(?:am|pm))\\s*(?:(?:to|\\-)\\s*(${ORDINAL_NUMBER_PATTERN})\\s*)?(?:(?:-|/|\\s*,\\s*|\\s+)(${YEAR_PATTERN}))?(?=\\W|$)(?!\\:\\d)`, "i");
var MONTH_NAME_GROUP2 = 1;
var DATE_GROUP2 = 2;
var DATE_TO_GROUP2 = 3;
var YEAR_GROUP2 = 4;
var ENMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(shouldSkipYearLikeDate) {
    super();
    __publicField(this, "shouldSkipYearLikeDate");
    this.shouldSkipYearLikeDate = shouldSkipYearLikeDate;
  }
  innerPattern() {
    return PATTERN2;
  }
  innerExtract(context, match) {
    const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP2].toLowerCase()];
    const day = parseOrdinalNumberPattern(match[DATE_GROUP2]);
    if (day > 31) {
      return null;
    }
    if (this.shouldSkipYearLikeDate) {
      if (!match[DATE_TO_GROUP2] && !match[YEAR_GROUP2] && match[DATE_GROUP2].match(/^2[0-5]$/)) {
        return null;
      }
    }
    const components = context.createParsingComponents({
      day,
      month
    }).addTag("parser/ENMonthNameMiddleEndianParser");
    if (match[YEAR_GROUP2]) {
      const year3 = parseYear(match[YEAR_GROUP2]);
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      components.imply("year", year3);
    }
    if (!match[DATE_TO_GROUP2]) {
      return components;
    }
    const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP2]);
    const result = context.createParsingResult(match.index, match[0]);
    result.start = components;
    result.end = components.clone();
    result.end.assign("day", endDate);
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameParser.js
var PATTERN3 = new RegExp(`((?:in)\\s*)?(${matchAnyPattern(MONTH_DICTIONARY)})\\s*(?:(?:,|-|of)?\\s*(${YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
var PREFIX_GROUP = 1;
var MONTH_NAME_GROUP3 = 2;
var YEAR_GROUP3 = 3;
var ENMonthNameParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN3;
  }
  innerExtract(context, match) {
    const monthName = match[MONTH_NAME_GROUP3].toLowerCase();
    if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {
      return null;
    }
    const result = context.createParsingResult(match.index + (match[PREFIX_GROUP] || "").length, match.index + match[0].length);
    result.start.imply("day", 1);
    result.start.addTag("parser/ENMonthNameParser");
    const month = MONTH_DICTIONARY[monthName];
    result.start.assign("month", month);
    if (match[YEAR_GROUP3]) {
      const year3 = parseYear(match[YEAR_GROUP3]);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, 1, month);
      result.start.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENYearMonthDayParser.js
var PATTERN4 = new RegExp(`([0-9]{4})[-\\.\\/\\s](?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[-\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
var YEAR_NUMBER_GROUP = 1;
var MONTH_NAME_GROUP4 = 2;
var MONTH_NUMBER_GROUP = 3;
var DATE_NUMBER_GROUP = 4;
var ENYearMonthDayParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMonthDateOrder) {
    super();
    __publicField(this, "strictMonthDateOrder");
    this.strictMonthDateOrder = strictMonthDateOrder;
  }
  innerPattern() {
    return PATTERN4;
  }
  innerExtract(context, match) {
    const year3 = parseInt(match[YEAR_NUMBER_GROUP]);
    let day = parseInt(match[DATE_NUMBER_GROUP]);
    let month = match[MONTH_NUMBER_GROUP] ? parseInt(match[MONTH_NUMBER_GROUP]) : MONTH_DICTIONARY[match[MONTH_NAME_GROUP4].toLowerCase()];
    if (month < 1 || month > 12) {
      if (this.strictMonthDateOrder) {
        return null;
      }
      if (day >= 1 && day <= 12) {
        [month, day] = [day, month];
      }
    }
    if (day < 1 || day > 31) {
      return null;
    }
    return {
      day,
      month,
      year: year3
    };
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENSlashMonthFormatParser.js
var PATTERN5 = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
var MONTH_GROUP = 1;
var YEAR_GROUP4 = 2;
var ENSlashMonthFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN5;
  }
  innerExtract(context, match) {
    const year3 = parseInt(match[YEAR_GROUP4]);
    const month = parseInt(match[MONTH_GROUP]);
    return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year3);
  }
};

// node_modules/chrono-node/dist/esm/common/parsers/AbstractTimeExpressionParser.js
function primaryTimePattern(leftBoundary, primaryPrefix, primarySuffix, flags) {
  return new RegExp(`${leftBoundary}${primaryPrefix}(\\d{1,4})(?:(?:\\.|:|：)(\\d{1,2})(?:(?::|：)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${primarySuffix}`, flags);
}
function followingTimePatten(followingPhase, followingSuffix) {
  return new RegExp(`^(${followingPhase})(\\d{1,4})(?:(?:\\.|\\:|\\：)(\\d{1,2})(?:(?:\\.|\\:|\\：)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${followingSuffix}`, "i");
}
var HOUR_GROUP = 2;
var MINUTE_GROUP = 3;
var SECOND_GROUP = 4;
var MILLI_SECOND_GROUP = 5;
var AM_PM_HOUR_GROUP = 6;
var AbstractTimeExpressionParser = class {
  constructor(strictMode = false) {
    __publicField(this, "strictMode");
    __publicField(this, "cachedPrimaryPrefix", null);
    __publicField(this, "cachedPrimarySuffix", null);
    __publicField(this, "cachedPrimaryTimePattern", null);
    __publicField(this, "cachedFollowingPhase", null);
    __publicField(this, "cachedFollowingSuffix", null);
    __publicField(this, "cachedFollowingTimePatten", null);
    this.strictMode = strictMode;
  }
  patternFlags() {
    return "i";
  }
  primaryPatternLeftBoundary() {
    return `(^|\\s|T|\\b)`;
  }
  primarySuffix() {
    return `(?!/)(?=\\W|$)`;
  }
  followingSuffix() {
    return `(?!/)(?=\\W|$)`;
  }
  pattern(context) {
    return this.getPrimaryTimePatternThroughCache();
  }
  extract(context, match) {
    const startComponents = this.extractPrimaryTimeComponents(context, match);
    if (!startComponents) {
      if (match[0].match(/^\d{4}/)) {
        match.index += 4;
        return null;
      }
      match.index += match[0].length;
      return null;
    }
    const index = match.index + match[1].length;
    const text = match[0].substring(match[1].length);
    const result = context.createParsingResult(index, text, startComponents);
    match.index += match[0].length;
    const remainingText = context.text.substring(match.index);
    const followingPattern = this.getFollowingTimePatternThroughCache();
    const followingMatch = followingPattern.exec(remainingText);
    if (text.match(/^\d{3,4}/) && followingMatch) {
      if (followingMatch[0].match(/^\s*([+-])\s*\d{2,4}$/)) {
        return null;
      }
      if (followingMatch[0].match(/^\s*([+-])\s*\d{2}\W\d{2}/)) {
        return null;
      }
    }
    if (!followingMatch || followingMatch[0].match(/^\s*([+-])\s*\d{3,4}$/)) {
      return this.checkAndReturnWithoutFollowingPattern(result);
    }
    result.end = this.extractFollowingTimeComponents(context, followingMatch, result);
    if (result.end) {
      result.text += followingMatch[0];
    }
    return this.checkAndReturnWithFollowingPattern(result);
  }
  extractPrimaryTimeComponents(context, match, strict16 = false) {
    const components = context.createParsingComponents();
    let minute = 0;
    let meridiem = null;
    let hour = parseInt(match[HOUR_GROUP]);
    if (hour > 100) {
      if (match[HOUR_GROUP].length == 4 && match[MINUTE_GROUP] == null && !match[AM_PM_HOUR_GROUP]) {
        return null;
      }
      if (this.strictMode || match[MINUTE_GROUP] != null) {
        return null;
      }
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (hour > 24) {
      return null;
    }
    if (match[MINUTE_GROUP] != null) {
      if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {
        return null;
      }
      minute = parseInt(match[MINUTE_GROUP]);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 12) {
      meridiem = Meridiem.PM;
    }
    if (match[AM_PM_HOUR_GROUP] != null) {
      if (hour > 12)
        return null;
      const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
      if (ampm == "a") {
        meridiem = Meridiem.AM;
        if (hour == 12) {
          hour = 0;
        }
      }
      if (ampm == "p") {
        meridiem = Meridiem.PM;
        if (hour != 12) {
          hour += 12;
        }
      }
    }
    components.assign("hour", hour);
    components.assign("minute", minute);
    if (meridiem !== null) {
      components.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        components.imply("meridiem", Meridiem.AM);
      } else {
        components.imply("meridiem", Meridiem.PM);
      }
    }
    if (match[MILLI_SECOND_GROUP] != null) {
      const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
      if (millisecond >= 1e3)
        return null;
      components.assign("millisecond", millisecond);
    }
    if (match[SECOND_GROUP] != null) {
      const second = parseInt(match[SECOND_GROUP]);
      if (second >= 60)
        return null;
      components.assign("second", second);
    }
    return components;
  }
  extractFollowingTimeComponents(context, match, result) {
    const components = context.createParsingComponents();
    if (match[MILLI_SECOND_GROUP] != null) {
      const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));
      if (millisecond >= 1e3)
        return null;
      components.assign("millisecond", millisecond);
    }
    if (match[SECOND_GROUP] != null) {
      const second = parseInt(match[SECOND_GROUP]);
      if (second >= 60)
        return null;
      components.assign("second", second);
    }
    let hour = parseInt(match[HOUR_GROUP]);
    let minute = 0;
    let meridiem = -1;
    if (match[MINUTE_GROUP] != null) {
      minute = parseInt(match[MINUTE_GROUP]);
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60 || hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = Meridiem.PM;
    }
    if (match[AM_PM_HOUR_GROUP] != null) {
      if (hour > 12) {
        return null;
      }
      const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();
      if (ampm == "a") {
        meridiem = Meridiem.AM;
        if (hour == 12) {
          hour = 0;
          if (!components.isCertain("day")) {
            components.imply("day", components.get("day") + 1);
          }
        }
      }
      if (ampm == "p") {
        meridiem = Meridiem.PM;
        if (hour != 12)
          hour += 12;
      }
      if (!result.start.isCertain("meridiem")) {
        if (meridiem == Meridiem.AM) {
          result.start.imply("meridiem", Meridiem.AM);
          if (result.start.get("hour") == 12) {
            result.start.assign("hour", 0);
          }
        } else {
          result.start.imply("meridiem", Meridiem.PM);
          if (result.start.get("hour") != 12) {
            result.start.assign("hour", result.start.get("hour") + 12);
          }
        }
      }
    }
    components.assign("hour", hour);
    components.assign("minute", minute);
    if (meridiem >= 0) {
      components.assign("meridiem", meridiem);
    } else {
      const startAtPM = result.start.isCertain("meridiem") && result.start.get("hour") > 12;
      if (startAtPM) {
        if (result.start.get("hour") - 12 > hour) {
          components.imply("meridiem", Meridiem.AM);
        } else if (hour <= 12) {
          components.assign("hour", hour + 12);
          components.assign("meridiem", Meridiem.PM);
        }
      } else if (hour > 12) {
        components.imply("meridiem", Meridiem.PM);
      } else if (hour <= 12) {
        components.imply("meridiem", Meridiem.AM);
      }
    }
    if (components.date().getTime() < result.start.date().getTime()) {
      components.imply("day", components.get("day") + 1);
    }
    return components;
  }
  checkAndReturnWithoutFollowingPattern(result) {
    if (result.text.match(/^\d$/)) {
      return null;
    }
    if (result.text.match(/^\d\d\d+$/)) {
      return null;
    }
    if (result.text.match(/\d[apAP]$/)) {
      return null;
    }
    const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)$/);
    if (endingWithNumbers) {
      const endingNumbers = endingWithNumbers[1];
      if (this.strictMode) {
        return null;
      }
      if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
        return null;
      }
      const endingNumberVal = parseInt(endingNumbers);
      if (endingNumberVal > 24) {
        return null;
      }
    }
    return result;
  }
  checkAndReturnWithFollowingPattern(result) {
    if (result.text.match(/^\d+-\d+$/)) {
      return null;
    }
    const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)\s*-\s*(\d[\d.]+)$/);
    if (endingWithNumbers) {
      if (this.strictMode) {
        return null;
      }
      const startingNumbers = endingWithNumbers[1];
      const endingNumbers = endingWithNumbers[2];
      if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
        return null;
      }
      const endingNumberVal = parseInt(endingNumbers);
      const startingNumberVal = parseInt(startingNumbers);
      if (endingNumberVal > 24 || startingNumberVal > 24) {
        return null;
      }
    }
    return result;
  }
  getPrimaryTimePatternThroughCache() {
    const primaryPrefix = this.primaryPrefix();
    const primarySuffix = this.primarySuffix();
    if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {
      return this.cachedPrimaryTimePattern;
    }
    this.cachedPrimaryTimePattern = primaryTimePattern(this.primaryPatternLeftBoundary(), primaryPrefix, primarySuffix, this.patternFlags());
    this.cachedPrimaryPrefix = primaryPrefix;
    this.cachedPrimarySuffix = primarySuffix;
    return this.cachedPrimaryTimePattern;
  }
  getFollowingTimePatternThroughCache() {
    const followingPhase = this.followingPhase();
    const followingSuffix = this.followingSuffix();
    if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {
      return this.cachedFollowingTimePatten;
    }
    this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);
    this.cachedFollowingPhase = followingPhase;
    this.cachedFollowingSuffix = followingSuffix;
    return this.cachedFollowingTimePatten;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeExpressionParser.js
var ENTimeExpressionParser = class extends AbstractTimeExpressionParser {
  constructor(strictMode) {
    super(strictMode);
  }
  followingPhase() {
    return "\\s*(?:\\-|\\–|\\~|\\〜|to|until|through|till|\\?)\\s*";
  }
  primaryPrefix() {
    return "(?:(?:at|from)\\s*)??";
  }
  primarySuffix() {
    return "(?:\\s*(?:o\\W*clock|at\\s*night|in\\s*the\\s*(?:morning|afternoon)))?(?!/)(?=\\W|$)";
  }
  extractPrimaryTimeComponents(context, match) {
    const components = super.extractPrimaryTimeComponents(context, match);
    if (!components) {
      return components;
    }
    if (match[0].endsWith("night")) {
      const hour = components.get("hour");
      if (hour >= 6 && hour < 12) {
        components.assign("hour", components.get("hour") + 12);
        components.assign("meridiem", Meridiem.PM);
      } else if (hour < 6) {
        components.assign("meridiem", Meridiem.AM);
      }
    }
    if (match[0].endsWith("afternoon")) {
      components.assign("meridiem", Meridiem.PM);
      const hour = components.get("hour");
      if (hour >= 0 && hour <= 6) {
        components.assign("hour", components.get("hour") + 12);
      }
    }
    if (match[0].endsWith("morning")) {
      components.assign("meridiem", Meridiem.AM);
      const hour = components.get("hour");
      if (hour < 12) {
        components.assign("hour", components.get("hour"));
      }
    }
    return components.addTag("parser/ENTimeExpressionParser");
  }
  extractFollowingTimeComponents(context, match, result) {
    const followingComponents = super.extractFollowingTimeComponents(context, match, result);
    if (followingComponents) {
      followingComponents.addTag("parser/ENTimeExpressionParser");
    }
    return followingComponents;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitAgoFormatParser.js
var PATTERN6 = new RegExp(`(${TIME_UNITS_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=\\W|$)`, "i");
var STRICT_PATTERN = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=\\W|$)`, "i");
var ENTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMode) {
    super();
    __publicField(this, "strictMode");
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN : PATTERN6;
  }
  innerExtract(context, match) {
    const duration = parseDuration(match[1]);
    if (!duration) {
      return null;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, reverseDuration(duration));
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitLaterFormatParser.js
var PATTERN7 = new RegExp(`(${TIME_UNITS_PATTERN})\\s{0,5}(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))`, "i");
var STRICT_PATTERN2 = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\s{0,5}(later|after|from now)(?=\\W|$)`, "i");
var GROUP_NUM_TIMEUNITS = 1;
var ENTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMode) {
    super();
    __publicField(this, "strictMode");
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN2 : PATTERN7;
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration(match[GROUP_NUM_TIMEUNITS]);
    if (!timeUnits) {
      return null;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/common/abstractRefiners.js
var Filter = class {
  refine(context, results) {
    return results.filter((r) => this.isValid(context, r));
  }
};
var MergingRefiner = class {
  refine(context, results) {
    if (results.length < 2) {
      return results;
    }
    const mergedResults = [];
    let curResult = results[0];
    let nextResult = null;
    for (let i = 1; i < results.length; i++) {
      nextResult = results[i];
      const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);
      if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {
        mergedResults.push(curResult);
        curResult = nextResult;
      } else {
        const left = curResult;
        const right = nextResult;
        const mergedResult = this.mergeResults(textBetween, left, right, context);
        context.debug(() => {
          console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);
        });
        curResult = mergedResult;
      }
    }
    if (curResult != null) {
      mergedResults.push(curResult);
    }
    return mergedResults;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/AbstractMergeDateRangeRefiner.js
var AbstractMergeDateRangeRefiner = class extends MergingRefiner {
  shouldMergeResults(textBetween, currentResult, nextResult) {
    return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;
  }
  mergeResults(textBetween, fromResult, toResult) {
    if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {
      toResult.start.getCertainComponents().forEach((key) => {
        if (!fromResult.start.isCertain(key)) {
          fromResult.start.imply(key, toResult.start.get(key));
        }
      });
      fromResult.start.getCertainComponents().forEach((key) => {
        if (!toResult.start.isCertain(key)) {
          toResult.start.imply(key, fromResult.start.get(key));
        }
      });
    }
    if (fromResult.start.date() > toResult.start.date()) {
      let fromDate = fromResult.start.date();
      let toDate = toResult.start.date();
      if (toResult.start.isOnlyWeekdayComponent() && addDuration(toDate, { day: 7 }) > fromDate) {
        toDate = addDuration(toDate, { day: 7 });
        toResult.start.imply("day", toDate.getDate());
        toResult.start.imply("month", toDate.getMonth() + 1);
        toResult.start.imply("year", toDate.getFullYear());
      } else if (fromResult.start.isOnlyWeekdayComponent() && addDuration(fromDate, { day: -7 }) < toDate) {
        fromDate = addDuration(fromDate, { day: -7 });
        fromResult.start.imply("day", fromDate.getDate());
        fromResult.start.imply("month", fromDate.getMonth() + 1);
        fromResult.start.imply("year", fromDate.getFullYear());
      } else if (toResult.start.isDateWithUnknownYear() && addDuration(toDate, { year: 1 }) > fromDate) {
        toDate = addDuration(toDate, { year: 1 });
        toResult.start.imply("year", toDate.getFullYear());
      } else if (fromResult.start.isDateWithUnknownYear() && addDuration(fromDate, { year: -1 }) < toDate) {
        fromDate = addDuration(fromDate, { year: -1 });
        fromResult.start.imply("year", fromDate.getFullYear());
      } else {
        [toResult, fromResult] = [fromResult, toResult];
      }
    }
    const result = fromResult.clone();
    result.start = fromResult.start;
    result.end = toResult.start;
    result.index = Math.min(fromResult.index, toResult.index);
    if (fromResult.index < toResult.index) {
      result.text = fromResult.text + textBetween + toResult.text;
    } else {
      result.text = toResult.text + textBetween + fromResult.text;
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeDateRangeRefiner.js
var ENMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(to|-|–|until|through|till)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/calculation/mergingCalculation.js
function mergeDateTimeResult(dateResult, timeResult) {
  const result = dateResult.clone();
  const beginDate = dateResult.start;
  const beginTime = timeResult.start;
  result.start = mergeDateTimeComponent(beginDate, beginTime);
  if (dateResult.end != null || timeResult.end != null) {
    const endDate = dateResult.end == null ? dateResult.start : dateResult.end;
    const endTime = timeResult.end == null ? timeResult.start : timeResult.end;
    const endDateTime = mergeDateTimeComponent(endDate, endTime);
    if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {
      const nextDay = new Date(endDateTime.date().getTime());
      nextDay.setDate(nextDay.getDate() + 1);
      if (endDateTime.isCertain("day")) {
        assignSimilarDate(endDateTime, nextDay);
      } else {
        implySimilarDate(endDateTime, nextDay);
      }
    }
    result.end = endDateTime;
  }
  return result;
}
function mergeDateTimeComponent(dateComponent, timeComponent) {
  const dateTimeComponent = dateComponent.clone();
  if (timeComponent.isCertain("hour")) {
    dateTimeComponent.assign("hour", timeComponent.get("hour"));
    dateTimeComponent.assign("minute", timeComponent.get("minute"));
    if (timeComponent.isCertain("second")) {
      dateTimeComponent.assign("second", timeComponent.get("second"));
      if (timeComponent.isCertain("millisecond")) {
        dateTimeComponent.assign("millisecond", timeComponent.get("millisecond"));
      } else {
        dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
      }
    } else {
      dateTimeComponent.imply("second", timeComponent.get("second"));
      dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
    }
  } else {
    dateTimeComponent.imply("hour", timeComponent.get("hour"));
    dateTimeComponent.imply("minute", timeComponent.get("minute"));
    dateTimeComponent.imply("second", timeComponent.get("second"));
    dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
  }
  if (timeComponent.isCertain("timezoneOffset")) {
    dateTimeComponent.assign("timezoneOffset", timeComponent.get("timezoneOffset"));
  }
  if (timeComponent.isCertain("meridiem")) {
    dateTimeComponent.assign("meridiem", timeComponent.get("meridiem"));
  } else if (timeComponent.get("meridiem") != null && dateTimeComponent.get("meridiem") == null) {
    dateTimeComponent.imply("meridiem", timeComponent.get("meridiem"));
  }
  if (dateTimeComponent.get("meridiem") == Meridiem.PM && dateTimeComponent.get("hour") < 12) {
    if (timeComponent.isCertain("hour")) {
      dateTimeComponent.assign("hour", dateTimeComponent.get("hour") + 12);
    } else {
      dateTimeComponent.imply("hour", dateTimeComponent.get("hour") + 12);
    }
  }
  dateTimeComponent.addTags(dateComponent.tags());
  dateTimeComponent.addTags(timeComponent.tags());
  return dateTimeComponent;
}

// node_modules/chrono-node/dist/esm/common/refiners/AbstractMergeDateTimeRefiner.js
var AbstractMergeDateTimeRefiner = class extends MergingRefiner {
  shouldMergeResults(textBetween, currentResult, nextResult) {
    return (currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime() || nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime()) && textBetween.match(this.patternBetween()) != null;
  }
  mergeResults(textBetween, currentResult, nextResult) {
    const result = currentResult.start.isOnlyDate() ? mergeDateTimeResult(currentResult, nextResult) : mergeDateTimeResult(nextResult, currentResult);
    result.index = currentResult.index;
    result.text = currentResult.text + textBetween + nextResult.text;
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeDateTimeRefiner.js
var ENMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(T|at|after|before|on|of|,|-|\\.|∙|:)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/ExtractTimezoneAbbrRefiner.js
var TIMEZONE_NAME_PATTERN = new RegExp("^\\s*,?\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", "i");
var ExtractTimezoneAbbrRefiner = class {
  constructor(timezoneOverrides) {
    __publicField(this, "timezoneOverrides");
    this.timezoneOverrides = timezoneOverrides;
  }
  refine(context, results) {
    const timezoneOverrides = context.option.timezones ?? {};
    results.forEach((result) => {
      const suffix = context.text.substring(result.index + result.text.length);
      const match = TIMEZONE_NAME_PATTERN.exec(suffix);
      if (!match) {
        return;
      }
      const timezoneAbbr = match[1].toUpperCase();
      const refDate = result.start.date() ?? result.refDate ?? /* @__PURE__ */ new Date();
      const tzOverrides = { ...this.timezoneOverrides, ...timezoneOverrides };
      const extractedTimezoneOffset = toTimezoneOffset(timezoneAbbr, refDate, tzOverrides);
      if (extractedTimezoneOffset == null) {
        return;
      }
      context.debug(() => {
        console.log(`Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`);
      });
      const currentTimezoneOffset = result.start.get("timezoneOffset");
      if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {
        if (result.start.isCertain("timezoneOffset")) {
          return;
        }
        if (timezoneAbbr != match[1]) {
          return;
        }
      }
      if (result.start.isOnlyDate()) {
        if (timezoneAbbr != match[1]) {
          return;
        }
      }
      result.text += match[0];
      if (!result.start.isCertain("timezoneOffset")) {
        result.start.assign("timezoneOffset", extractedTimezoneOffset);
      }
      if (result.end != null && !result.end.isCertain("timezoneOffset")) {
        result.end.assign("timezoneOffset", extractedTimezoneOffset);
      }
    });
    return results;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/ExtractTimezoneOffsetRefiner.js
var TIMEZONE_OFFSET_PATTERN = new RegExp("^\\s*(?:\\(?(?:GMT|UTC)\\s?)?([+-])(\\d{1,2})(?::?(\\d{2}))?\\)?", "i");
var TIMEZONE_OFFSET_SIGN_GROUP = 1;
var TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;
var TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;
var ExtractTimezoneOffsetRefiner = class {
  refine(context, results) {
    results.forEach(function(result) {
      if (result.start.isCertain("timezoneOffset")) {
        return;
      }
      const suffix = context.text.substring(result.index + result.text.length);
      const match = TIMEZONE_OFFSET_PATTERN.exec(suffix);
      if (!match) {
        return;
      }
      context.debug(() => {
        console.log(`Extracting timezone: '${match[0]}' into : ${result}`);
      });
      const hourOffset = parseInt(match[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);
      const minuteOffset = parseInt(match[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || "0");
      let timezoneOffset = hourOffset * 60 + minuteOffset;
      if (timezoneOffset > 14 * 60) {
        return;
      }
      if (match[TIMEZONE_OFFSET_SIGN_GROUP] === "-") {
        timezoneOffset = -timezoneOffset;
      }
      if (result.end != null) {
        result.end.assign("timezoneOffset", timezoneOffset);
      }
      result.start.assign("timezoneOffset", timezoneOffset);
      result.text += match[0];
    });
    return results;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/OverlapRemovalRefiner.js
var OverlapRemovalRefiner = class {
  refine(context, results) {
    if (results.length < 2) {
      return results;
    }
    const filteredResults = [];
    let prevResult = results[0];
    for (let i = 1; i < results.length; i++) {
      const result = results[i];
      if (result.index >= prevResult.index + prevResult.text.length) {
        filteredResults.push(prevResult);
        prevResult = result;
        continue;
      }
      let kept = null;
      let removed = null;
      if (result.text.length > prevResult.text.length) {
        kept = result;
        removed = prevResult;
      } else {
        kept = prevResult;
        removed = result;
      }
      context.debug(() => {
        console.log(`${this.constructor.name} remove ${removed} by ${kept}`);
      });
      prevResult = kept;
    }
    if (prevResult != null) {
      filteredResults.push(prevResult);
    }
    return filteredResults;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/ForwardDateRefiner.js
var ForwardDateRefiner = class {
  refine(context, results) {
    if (!context.option.forwardDate) {
      return results;
    }
    results.forEach((result) => {
      let refDate = context.reference.getDateWithAdjustedTimezone();
      if (result.start.isOnlyTime() && context.reference.instant > result.start.date()) {
        const refDate2 = context.reference.getDateWithAdjustedTimezone();
        const refFollowingDay = new Date(refDate2);
        refFollowingDay.setDate(refFollowingDay.getDate() + 1);
        implySimilarDate(result.start, refFollowingDay);
        context.debug(() => {
          console.log(`${this.constructor.name} adjusted ${result} time from the ref date (${refDate2}) to the following day (${refFollowingDay})`);
        });
        if (result.end && result.end.isOnlyTime()) {
          implySimilarDate(result.end, refFollowingDay);
          if (result.start.date() > result.end.date()) {
            refFollowingDay.setDate(refFollowingDay.getDate() + 1);
            implySimilarDate(result.end, refFollowingDay);
          }
        }
      }
      if (result.start.isOnlyWeekdayComponent() && refDate > result.start.date()) {
        let daysToAdd = result.start.get("weekday") - refDate.getDay();
        if (daysToAdd <= 0) {
          daysToAdd += 7;
        }
        refDate = addDuration(refDate, { day: daysToAdd });
        implySimilarDate(result.start, refDate);
        context.debug(() => {
          console.log(`${this.constructor.name} adjusted ${result} weekday (${result.start})`);
        });
        if (result.end && result.end.isOnlyWeekdayComponent()) {
          let daysToAdd2 = result.end.get("weekday") - refDate.getDay();
          if (daysToAdd2 <= 0) {
            daysToAdd2 += 7;
          }
          refDate = addDuration(refDate, { day: daysToAdd2 });
          implySimilarDate(result.end, refDate);
          context.debug(() => {
            console.log(`${this.constructor.name} adjusted ${result} weekday (${result.end})`);
          });
        }
      }
      if (result.start.isDateWithUnknownYear() && refDate > result.start.date()) {
        for (let i = 0; i < 3 && refDate > result.start.date(); i++) {
          result.start.imply("year", result.start.get("year") + 1);
          context.debug(() => {
            console.log(`${this.constructor.name} adjusted ${result} year (${result.start})`);
          });
          if (result.end && !result.end.isCertain("year")) {
            result.end.imply("year", result.end.get("year") + 1);
            context.debug(() => {
              console.log(`${this.constructor.name} adjusted ${result} month (${result.start})`);
            });
          }
        }
      }
    });
    return results;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/UnlikelyFormatFilter.js
var UnlikelyFormatFilter = class extends Filter {
  constructor(strictMode) {
    super();
    __publicField(this, "strictMode");
    this.strictMode = strictMode;
  }
  isValid(context, result) {
    if (result.text.replace(" ", "").match(/^\d*(\.\d*)?$/)) {
      context.debug(() => {
        console.log(`Removing unlikely result '${result.text}'`);
      });
      return false;
    }
    if (!result.start.isValidDate()) {
      context.debug(() => {
        console.log(`Removing invalid result: ${result} (${result.start})`);
      });
      return false;
    }
    if (result.end && !result.end.isValidDate()) {
      context.debug(() => {
        console.log(`Removing invalid result: ${result} (${result.end})`);
      });
      return false;
    }
    if (this.strictMode) {
      return this.isStrictModeValid(context, result);
    }
    return true;
  }
  isStrictModeValid(context, result) {
    if (result.start.isOnlyWeekdayComponent()) {
      context.debug(() => {
        console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);
      });
      return false;
    }
    return true;
  }
};

// node_modules/chrono-node/dist/esm/common/parsers/ISOFormatParser.js
var PATTERN8 = new RegExp("([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})(?:T([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?(Z|([+-]\\d{2}):?(\\d{2})?)?)?(?=\\W|$)", "i");
var YEAR_NUMBER_GROUP2 = 1;
var MONTH_NUMBER_GROUP2 = 2;
var DATE_NUMBER_GROUP2 = 3;
var HOUR_NUMBER_GROUP = 4;
var MINUTE_NUMBER_GROUP = 5;
var SECOND_NUMBER_GROUP = 6;
var MILLISECOND_NUMBER_GROUP = 7;
var TZD_GROUP = 8;
var TZD_HOUR_OFFSET_GROUP = 9;
var TZD_MINUTE_OFFSET_GROUP = 10;
var ISOFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN8;
  }
  innerExtract(context, match) {
    const components = context.createParsingComponents({
      "year": parseInt(match[YEAR_NUMBER_GROUP2]),
      "month": parseInt(match[MONTH_NUMBER_GROUP2]),
      "day": parseInt(match[DATE_NUMBER_GROUP2])
    });
    if (match[HOUR_NUMBER_GROUP] != null) {
      components.assign("hour", parseInt(match[HOUR_NUMBER_GROUP]));
      components.assign("minute", parseInt(match[MINUTE_NUMBER_GROUP]));
      if (match[SECOND_NUMBER_GROUP] != null) {
        components.assign("second", parseInt(match[SECOND_NUMBER_GROUP]));
      }
      if (match[MILLISECOND_NUMBER_GROUP] != null) {
        components.assign("millisecond", parseInt(match[MILLISECOND_NUMBER_GROUP]));
      }
      if (match[TZD_GROUP] != null) {
        let offset = 0;
        if (match[TZD_HOUR_OFFSET_GROUP]) {
          const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);
          let minuteOffset = 0;
          if (match[TZD_MINUTE_OFFSET_GROUP] != null) {
            minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);
          }
          offset = hourOffset * 60;
          if (offset < 0) {
            offset -= minuteOffset;
          } else {
            offset += minuteOffset;
          }
        }
        components.assign("timezoneOffset", offset);
      }
    }
    return components.addTag("parser/ISOFormatParser");
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/MergeWeekdayComponentRefiner.js
var MergeWeekdayComponentRefiner = class extends MergingRefiner {
  mergeResults(textBetween, currentResult, nextResult) {
    const newResult = nextResult.clone();
    newResult.index = currentResult.index;
    newResult.text = currentResult.text + textBetween + newResult.text;
    newResult.start.assign("weekday", currentResult.start.get("weekday"));
    if (newResult.end) {
      newResult.end.assign("weekday", currentResult.start.get("weekday"));
    }
    return newResult;
  }
  shouldMergeResults(textBetween, currentResult, nextResult) {
    const weekdayThenNormalDate = currentResult.start.isOnlyWeekdayComponent() && !currentResult.start.isCertain("hour") && nextResult.start.isCertain("day");
    return weekdayThenNormalDate && textBetween.match(/^,?\s*$/) != null;
  }
};

// node_modules/chrono-node/dist/esm/configurations.js
function includeCommonConfiguration(configuration2, strictMode = false) {
  configuration2.parsers.unshift(new ISOFormatParser());
  configuration2.refiners.unshift(new MergeWeekdayComponentRefiner());
  configuration2.refiners.unshift(new ExtractTimezoneOffsetRefiner());
  configuration2.refiners.unshift(new OverlapRemovalRefiner());
  configuration2.refiners.push(new ExtractTimezoneAbbrRefiner());
  configuration2.refiners.push(new OverlapRemovalRefiner());
  configuration2.refiners.push(new ForwardDateRefiner());
  configuration2.refiners.push(new UnlikelyFormatFilter(strictMode));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/common/casualReferences.js
function now(reference) {
  const targetDate = reference.getDateWithAdjustedTimezone();
  const component = new ParsingComponents(reference, {});
  assignSimilarDate(component, targetDate);
  assignSimilarTime(component, targetDate);
  component.assign("timezoneOffset", reference.getTimezoneOffset());
  component.addTag("casualReference/now");
  return component;
}
function today(reference) {
  const targetDate = reference.getDateWithAdjustedTimezone();
  const component = new ParsingComponents(reference, {});
  assignSimilarDate(component, targetDate);
  implySimilarTime(component, targetDate);
  component.delete("meridiem");
  component.addTag("casualReference/today");
  return component;
}
function yesterday(reference) {
  return theDayBefore(reference, 1).addTag("casualReference/yesterday");
}
function tomorrow(reference) {
  return theDayAfter(reference, 1).addTag("casualReference/tomorrow");
}
function theDayBefore(reference, numDay) {
  return theDayAfter(reference, -numDay);
}
function theDayAfter(reference, nDays) {
  const targetDate = reference.getDateWithAdjustedTimezone();
  const component = new ParsingComponents(reference, {});
  const newDate = new Date(targetDate.getTime());
  newDate.setDate(newDate.getDate() + nDays);
  assignSimilarDate(component, newDate);
  implySimilarTime(component, newDate);
  component.delete("meridiem");
  return component;
}
function tonight(reference, implyHour = 22) {
  const targetDate = reference.getDateWithAdjustedTimezone();
  const component = new ParsingComponents(reference, {});
  assignSimilarDate(component, targetDate);
  component.imply("hour", implyHour);
  component.imply("meridiem", Meridiem.PM);
  component.addTag("casualReference/tonight");
  return component;
}
function lastNight(reference, implyHour = 0) {
  let targetDate = reference.getDateWithAdjustedTimezone();
  const component = new ParsingComponents(reference, {});
  if (targetDate.getHours() < 6) {
    targetDate = new Date(targetDate.getTime() - 24 * 60 * 60 * 1e3);
  }
  assignSimilarDate(component, targetDate);
  component.imply("hour", implyHour);
  return component;
}
function evening(reference, implyHour = 20) {
  const component = new ParsingComponents(reference, {});
  component.imply("meridiem", Meridiem.PM);
  component.imply("hour", implyHour);
  component.addTag("casualReference/evening");
  return component;
}
function yesterdayEvening(reference, implyHour = 20) {
  let targetDate = reference.getDateWithAdjustedTimezone();
  const component = new ParsingComponents(reference, {});
  targetDate = new Date(targetDate.getTime() - 24 * 60 * 60 * 1e3);
  assignSimilarDate(component, targetDate);
  component.imply("hour", implyHour);
  component.imply("meridiem", Meridiem.PM);
  component.addTag("casualReference/yesterday");
  component.addTag("casualReference/evening");
  return component;
}
function midnight(reference) {
  const component = new ParsingComponents(reference, {});
  if (reference.getDateWithAdjustedTimezone().getHours() > 2) {
    component.addDurationAsImplied({ day: 1 });
  }
  component.assign("hour", 0);
  component.imply("minute", 0);
  component.imply("second", 0);
  component.imply("millisecond", 0);
  component.addTag("casualReference/midnight");
  return component;
}
function morning(reference, implyHour = 6) {
  const component = new ParsingComponents(reference, {});
  component.imply("meridiem", Meridiem.AM);
  component.imply("hour", implyHour);
  component.imply("minute", 0);
  component.imply("second", 0);
  component.imply("millisecond", 0);
  component.addTag("casualReference/morning");
  return component;
}
function afternoon(reference, implyHour = 15) {
  const component = new ParsingComponents(reference, {});
  component.imply("meridiem", Meridiem.PM);
  component.imply("hour", implyHour);
  component.imply("minute", 0);
  component.imply("second", 0);
  component.imply("millisecond", 0);
  component.addTag("casualReference/afternoon");
  return component;
}
function noon(reference) {
  const component = new ParsingComponents(reference, {});
  component.imply("meridiem", Meridiem.AM);
  component.assign("hour", 12);
  component.imply("minute", 0);
  component.imply("second", 0);
  component.imply("millisecond", 0);
  component.addTag("casualReference/noon");
  return component;
}

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualDateParser.js
var PATTERN9 = /(now|today|tonight|tomorrow|overmorrow|tmr|tmrw|yesterday|last\s*night)(?=\W|$)/i;
var ENCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return PATTERN9;
  }
  innerExtract(context, match) {
    let targetDate = context.refDate;
    const lowerText = match[0].toLowerCase();
    let component = context.createParsingComponents();
    switch (lowerText) {
      case "now":
        component = now(context.reference);
        break;
      case "today":
        component = today(context.reference);
        break;
      case "yesterday":
        component = yesterday(context.reference);
        break;
      case "tomorrow":
      case "tmr":
      case "tmrw":
        component = tomorrow(context.reference);
        break;
      case "tonight":
        component = tonight(context.reference);
        break;
      case "overmorrow":
        component = theDayAfter(context.reference, 2);
        break;
      default:
        if (lowerText.match(/last\s*night/)) {
          if (targetDate.getHours() > 6) {
            const previousDay = new Date(targetDate.getTime());
            previousDay.setDate(previousDay.getDate() - 1);
            targetDate = previousDay;
          }
          assignSimilarDate(component, targetDate);
          component.imply("hour", 0);
        }
        break;
    }
    component.addTag("parser/ENCasualDateParser");
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualTimeParser.js
var PATTERN10 = /(?:this)?\s{0,3}(morning|afternoon|evening|night|midnight|midday|noon)(?=\W|$)/i;
var ENCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN10;
  }
  innerExtract(context, match) {
    let component = null;
    switch (match[1].toLowerCase()) {
      case "afternoon":
        component = afternoon(context.reference);
        break;
      case "evening":
      case "night":
        component = evening(context.reference);
        break;
      case "midnight":
        component = midnight(context.reference);
        break;
      case "morning":
        component = morning(context.reference);
        break;
      case "noon":
      case "midday":
        component = noon(context.reference);
        break;
    }
    if (component) {
      component.addTag("parser/ENCasualTimeParser");
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/calculation/weekdays.js
function createParsingComponentsAtWeekday(reference, weekday, modifier) {
  const refDate = reference.getDateWithAdjustedTimezone();
  const daysToWeekday = getDaysToWeekday(refDate, weekday, modifier);
  let components = new ParsingComponents(reference);
  components = components.addDurationAsImplied({ day: daysToWeekday });
  components.assign("weekday", weekday);
  return components;
}
function getDaysToWeekday(refDate, weekday, modifier) {
  const refWeekday = refDate.getDay();
  switch (modifier) {
    case "this":
      return getDaysForwardToWeekday(refDate, weekday);
    case "last":
      return getBackwardDaysToWeekday(refDate, weekday);
    case "next":
      if (refWeekday == Weekday.SUNDAY) {
        return weekday == Weekday.SUNDAY ? 7 : weekday;
      }
      if (refWeekday == Weekday.SATURDAY) {
        if (weekday == Weekday.SATURDAY)
          return 7;
        if (weekday == Weekday.SUNDAY)
          return 8;
        return 1 + weekday;
      }
      if (weekday < refWeekday && weekday != Weekday.SUNDAY) {
        return getDaysForwardToWeekday(refDate, weekday);
      } else {
        return getDaysForwardToWeekday(refDate, weekday) + 7;
      }
  }
  return getDaysToWeekdayClosest(refDate, weekday);
}
function getDaysToWeekdayClosest(refDate, weekday) {
  const backward = getBackwardDaysToWeekday(refDate, weekday);
  const forward = getDaysForwardToWeekday(refDate, weekday);
  return forward < -backward ? forward : backward;
}
function getDaysForwardToWeekday(refDate, weekday) {
  const refWeekday = refDate.getDay();
  let forwardCount = weekday - refWeekday;
  if (forwardCount < 0) {
    forwardCount += 7;
  }
  return forwardCount;
}
function getBackwardDaysToWeekday(refDate, weekday) {
  const refWeekday = refDate.getDay();
  let backwardCount = weekday - refWeekday;
  if (backwardCount >= 0) {
    backwardCount -= 7;
  }
  return backwardCount;
}

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENWeekdayParser.js
var PATTERN11 = new RegExp(`(?:(?:\\,|\\(|\\（)\\s*)?(?:on\\s*?)?(?:(this|last|past|next)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY)}|weekend|weekday)(?:\\s*(?:\\,|\\)|\\）))?(?:\\s*(this|last|past|next)\\s*week)?(?=\\W|$)`, "i");
var PREFIX_GROUP2 = 1;
var WEEKDAY_GROUP = 2;
var POSTFIX_GROUP = 3;
var ENWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN11;
  }
  innerExtract(context, match) {
    const prefix = match[PREFIX_GROUP2];
    const postfix = match[POSTFIX_GROUP];
    let modifierWord = prefix || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord == "last" || modifierWord == "past") {
      modifier = "last";
    } else if (modifierWord == "next") {
      modifier = "next";
    } else if (modifierWord == "this") {
      modifier = "this";
    }
    const weekday_word = match[WEEKDAY_GROUP].toLowerCase();
    let weekday;
    if (WEEKDAY_DICTIONARY[weekday_word] !== void 0) {
      weekday = WEEKDAY_DICTIONARY[weekday_word];
    } else if (weekday_word == "weekend") {
      weekday = modifier == "last" ? Weekday.SUNDAY : Weekday.SATURDAY;
    } else if (weekday_word == "weekday") {
      const refWeekday = context.reference.getDateWithAdjustedTimezone().getDay();
      if (refWeekday == Weekday.SUNDAY || refWeekday == Weekday.SATURDAY) {
        weekday = modifier == "last" ? Weekday.FRIDAY : Weekday.MONDAY;
      } else {
        weekday = refWeekday - 1;
        weekday = modifier == "last" ? weekday - 1 : weekday + 1;
        weekday = weekday % 5 + 1;
      }
    } else {
      return null;
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENRelativeDateFormatParser.js
var PATTERN12 = new RegExp(`(this|last|past|next|after\\s*this)\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
var MODIFIER_WORD_GROUP = 1;
var RELATIVE_WORD_GROUP = 2;
var ENRelativeDateFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN12;
  }
  innerExtract(context, match) {
    const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();
    const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY[unitWord];
    if (modifier == "next" || modifier.startsWith("after")) {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "last" || modifier == "past") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = new Date(context.reference.instant.getTime());
    if (unitWord.match(/week/i)) {
      date.setDate(date.getDate() - date.getDay());
      components.imply("day", date.getDate());
      components.imply("month", date.getMonth() + 1);
      components.imply("year", date.getFullYear());
    } else if (unitWord.match(/month/i)) {
      date.setDate(1);
      components.imply("day", date.getDate());
      components.assign("year", date.getFullYear());
      components.assign("month", date.getMonth() + 1);
    } else if (unitWord.match(/year/i)) {
      date.setDate(1);
      date.setMonth(0);
      components.imply("day", date.getDate());
      components.imply("month", date.getMonth() + 1);
      components.assign("year", date.getFullYear());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/common/parsers/SlashDateFormatParser.js
var PATTERN13 = new RegExp("([^\\d]|^)([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})(?:[\\/\\.\\-]([0-9]{4}|[0-9]{2}))?(\\W|$)", "i");
var OPENING_GROUP = 1;
var ENDING_GROUP = 5;
var FIRST_NUMBERS_GROUP = 2;
var SECOND_NUMBERS_GROUP = 3;
var YEAR_GROUP5 = 4;
var SlashDateFormatParser = class {
  constructor(littleEndian) {
    __publicField(this, "groupNumberMonth");
    __publicField(this, "groupNumberDay");
    this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;
    this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;
  }
  pattern() {
    return PATTERN13;
  }
  extract(context, match) {
    const index = match.index + match[OPENING_GROUP].length;
    const indexEnd = match.index + match[0].length - match[ENDING_GROUP].length;
    if (index > 0) {
      const textBefore = context.text.substring(0, index);
      if (textBefore.match("\\d/?$")) {
        return;
      }
    }
    if (indexEnd < context.text.length) {
      const textAfter = context.text.substring(indexEnd);
      if (textAfter.match("^/?\\d")) {
        return;
      }
    }
    const text = context.text.substring(index, indexEnd);
    if (text.match(/^\d\.\d$/) || text.match(/^\d\.\d{1,2}\.\d{1,2}\s*$/)) {
      return;
    }
    if (!match[YEAR_GROUP5] && text.indexOf("/") < 0) {
      return;
    }
    const result = context.createParsingResult(index, text);
    let month = parseInt(match[this.groupNumberMonth]);
    let day = parseInt(match[this.groupNumberDay]);
    if (month < 1 || month > 12) {
      if (month > 12) {
        if (day >= 1 && day <= 12 && month <= 31) {
          [day, month] = [month, day];
        } else {
          return null;
        }
      }
    }
    if (day < 1 || day > 31) {
      return null;
    }
    result.start.assign("day", day);
    result.start.assign("month", month);
    if (match[YEAR_GROUP5]) {
      const rawYearNumber = parseInt(match[YEAR_GROUP5]);
      const year3 = findMostLikelyADYear(rawYearNumber);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    return result.addTag("parser/SlashDateFormatParser");
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js
var PATTERN14 = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
var PATTERN_NO_ABBR = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\W|$)`, "i");
var ENTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(allowAbbreviations = true) {
    super();
    __publicField(this, "allowAbbreviations");
    this.allowAbbreviations = allowAbbreviations;
  }
  innerPattern() {
    return this.allowAbbreviations ? PATTERN14 : PATTERN_NO_ABBR;
  }
  innerExtract(context, match) {
    const prefix = match[1].toLowerCase();
    let duration = parseDuration(match[2]);
    if (!duration) {
      return null;
    }
    switch (prefix) {
      case "last":
      case "past":
      case "-":
        duration = reverseDuration(duration);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, duration);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeRelativeAfterDateRefiner.js
function IsPositiveFollowingReference(result) {
  return result.text.match(/^[+-]/i) != null;
}
function IsNegativeFollowingReference(result) {
  return result.text.match(/^-/i) != null;
}
var ENMergeRelativeAfterDateRefiner = class extends MergingRefiner {
  shouldMergeResults(textBetween, currentResult, nextResult) {
    if (!textBetween.match(/^\s*$/i)) {
      return false;
    }
    return IsPositiveFollowingReference(nextResult) || IsNegativeFollowingReference(nextResult);
  }
  mergeResults(textBetween, currentResult, nextResult, context) {
    let timeUnits = parseDuration(nextResult.text);
    if (IsNegativeFollowingReference(nextResult)) {
      timeUnits = reverseDuration(timeUnits);
    }
    const components = ParsingComponents.createRelativeFromReference(ReferenceWithTimezone.fromDate(currentResult.start.date()), timeUnits);
    return new ParsingResult(currentResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeRelativeFollowByDateRefiner.js
function hasImpliedEarlierReferenceDate(result) {
  return result.text.match(/\s+(before|from)$/i) != null;
}
function hasImpliedLaterReferenceDate(result) {
  return result.text.match(/\s+(after|since)$/i) != null;
}
var ENMergeRelativeFollowByDateRefiner = class extends MergingRefiner {
  patternBetween() {
    return /^\s*$/i;
  }
  shouldMergeResults(textBetween, currentResult, nextResult) {
    if (!textBetween.match(this.patternBetween())) {
      return false;
    }
    if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {
      return false;
    }
    return !!nextResult.start.get("day") && !!nextResult.start.get("month") && !!nextResult.start.get("year");
  }
  mergeResults(textBetween, currentResult, nextResult) {
    let duration = parseDuration(currentResult.text);
    if (hasImpliedEarlierReferenceDate(currentResult)) {
      duration = reverseDuration(duration);
    }
    const components = ParsingComponents.createRelativeFromReference(ReferenceWithTimezone.fromDate(nextResult.start.date()), duration);
    return new ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENExtractYearSuffixRefiner.js
var YEAR_SUFFIX_PATTERN = new RegExp(`^\\s*(${YEAR_PATTERN})`, "i");
var YEAR_GROUP6 = 1;
var ENExtractYearSuffixRefiner = class {
  refine(context, results) {
    results.forEach(function(result) {
      if (!result.start.isDateWithUnknownYear()) {
        return;
      }
      const suffix = context.text.substring(result.index + result.text.length);
      const match = YEAR_SUFFIX_PATTERN.exec(suffix);
      if (!match) {
        return;
      }
      if (match[0].trim().length <= 3) {
        return;
      }
      context.debug(() => {
        console.log(`Extracting year: '${match[0]}' into : ${result}`);
      });
      const year3 = parseYear(match[YEAR_GROUP6]);
      if (result.end != null) {
        result.end.assign("year", year3);
      }
      result.start.assign("year", year3);
      result.text += match[0];
    });
    return results;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENUnlikelyFormatFilter.js
var ENUnlikelyFormatFilter = class extends Filter {
  constructor() {
    super();
  }
  isValid(context, result) {
    const text = result.text.trim();
    if (text === context.text.trim()) {
      return true;
    }
    if (text.toLowerCase() === "may") {
      const textBefore = context.text.substring(0, result.index).trim();
      if (!textBefore.match(/\b(in)$/i)) {
        context.debug(() => {
          console.log(`Removing unlikely result: ${result}`);
        });
        return false;
      }
    }
    if (text.toLowerCase().endsWith("the second")) {
      const textAfter = context.text.substring(result.index + result.text.length).trim();
      if (textAfter.length > 0) {
        context.debug(() => {
          console.log(`Removing unlikely result: ${result}`);
        });
      }
      return false;
    }
    return true;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/configuration.js
var ENDefaultConfiguration = class {
  createCasualConfiguration(littleEndian = false) {
    const option = this.createConfiguration(false, littleEndian);
    option.parsers.push(new ENCasualDateParser());
    option.parsers.push(new ENCasualTimeParser());
    option.parsers.push(new ENMonthNameParser());
    option.parsers.push(new ENRelativeDateFormatParser());
    option.parsers.push(new ENTimeUnitCasualRelativeFormatParser());
    option.refiners.push(new ENUnlikelyFormatFilter());
    return option;
  }
  createConfiguration(strictMode = true, littleEndian = false) {
    const options = includeCommonConfiguration({
      parsers: [
        new SlashDateFormatParser(littleEndian),
        new ENTimeUnitWithinFormatParser(strictMode),
        new ENMonthNameLittleEndianParser(),
        new ENMonthNameMiddleEndianParser(littleEndian),
        new ENWeekdayParser(),
        new ENSlashMonthFormatParser(),
        new ENTimeExpressionParser(strictMode),
        new ENTimeUnitAgoFormatParser(strictMode),
        new ENTimeUnitLaterFormatParser(strictMode)
      ],
      refiners: [new ENMergeDateTimeRefiner()]
    }, strictMode);
    options.parsers.unshift(new ENYearMonthDayParser(strictMode));
    options.refiners.unshift(new ENMergeRelativeFollowByDateRefiner());
    options.refiners.unshift(new ENMergeRelativeAfterDateRefiner());
    options.refiners.unshift(new OverlapRemovalRefiner());
    options.refiners.push(new ENMergeDateTimeRefiner());
    options.refiners.push(new ENExtractYearSuffixRefiner());
    options.refiners.push(new ENMergeDateRangeRefiner());
    return options;
  }
};

// node_modules/chrono-node/dist/esm/chrono.js
var Chrono = class _Chrono {
  constructor(configuration2) {
    __publicField(this, "parsers");
    __publicField(this, "refiners");
    __publicField(this, "defaultConfig", new ENDefaultConfiguration());
    configuration2 = configuration2 || this.defaultConfig.createCasualConfiguration();
    this.parsers = [...configuration2.parsers];
    this.refiners = [...configuration2.refiners];
  }
  clone() {
    return new _Chrono({
      parsers: [...this.parsers],
      refiners: [...this.refiners]
    });
  }
  parseDate(text, referenceDate, option) {
    const results = this.parse(text, referenceDate, option);
    return results.length > 0 ? results[0].start.date() : null;
  }
  parse(text, referenceDate, option) {
    const context = new ParsingContext(text, referenceDate, option);
    let results = [];
    this.parsers.forEach((parser) => {
      const parsedResults = _Chrono.executeParser(context, parser);
      results = results.concat(parsedResults);
    });
    results.sort((a, b) => {
      return a.index - b.index;
    });
    this.refiners.forEach(function(refiner) {
      results = refiner.refine(context, results);
    });
    return results;
  }
  static executeParser(context, parser) {
    const results = [];
    const pattern = parser.pattern(context);
    const originalText = context.text;
    let remainingText = context.text;
    let match = pattern.exec(remainingText);
    while (match) {
      const index = match.index + originalText.length - remainingText.length;
      match.index = index;
      const result = parser.extract(context, match);
      if (!result) {
        remainingText = originalText.substring(match.index + 1);
        match = pattern.exec(remainingText);
        continue;
      }
      let parsedResult = null;
      if (result instanceof ParsingResult) {
        parsedResult = result;
      } else if (result instanceof ParsingComponents) {
        parsedResult = context.createParsingResult(match.index, match[0]);
        parsedResult.start = result;
      } else {
        parsedResult = context.createParsingResult(match.index, match[0], result);
      }
      const parsedIndex = parsedResult.index;
      const parsedText = parsedResult.text;
      context.debug(() => console.log(`${parser.constructor.name} extracted (at index=${parsedIndex}) '${parsedText}'`));
      results.push(parsedResult);
      remainingText = originalText.substring(parsedIndex + parsedText.length);
      match = pattern.exec(remainingText);
    }
    return results;
  }
};
var ParsingContext = class {
  constructor(text, refDate, option) {
    __publicField(this, "text");
    __publicField(this, "option");
    __publicField(this, "reference");
    __publicField(this, "refDate");
    this.text = text;
    this.option = option ?? {};
    this.reference = ReferenceWithTimezone.fromInput(refDate, this.option.timezones);
    this.refDate = this.reference.instant;
  }
  createParsingComponents(components) {
    if (components instanceof ParsingComponents) {
      return components;
    }
    return new ParsingComponents(this.reference, components);
  }
  createParsingResult(index, textOrEndIndex, startComponents, endComponents) {
    const text = typeof textOrEndIndex === "string" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);
    const start = startComponents ? this.createParsingComponents(startComponents) : null;
    const end = endComponents ? this.createParsingComponents(endComponents) : null;
    return new ParsingResult(this.reference, index, text, start, end);
  }
  debug(block) {
    if (this.option.debug) {
      if (this.option.debug instanceof Function) {
        this.option.debug(block);
      } else {
        const handler = this.option.debug;
        handler.debug(block);
      }
    }
  }
};

// node_modules/chrono-node/dist/esm/locales/en/index.js
var configuration = new ENDefaultConfiguration();
var casual = new Chrono(configuration.createCasualConfiguration(false));
var strict = new Chrono(configuration.createConfiguration(true, false));
var GB = new Chrono(configuration.createCasualConfiguration(true));
function parse(text, ref, option) {
  return casual.parse(text, ref, option);
}
function parseDate(text, ref, option) {
  return casual.parseDate(text, ref, option);
}

// node_modules/chrono-node/dist/esm/locales/de/index.js
var de_exports = {};
__export(de_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual2,
  createCasualConfiguration: () => createCasualConfiguration,
  createConfiguration: () => createConfiguration,
  parse: () => parse2,
  parseDate: () => parseDate2,
  strict: () => strict2
});

// node_modules/chrono-node/dist/esm/locales/de/parsers/DETimeExpressionParser.js
var DETimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:um|von)\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\–|\\~|\\〜|bis)\\s*";
  }
  extractPrimaryTimeComponents(context, match) {
    if (match[0].match(/^\s*\d{4}\s*$/)) {
      return null;
    }
    return super.extractPrimaryTimeComponents(context, match);
  }
};

// node_modules/chrono-node/dist/esm/locales/de/constants.js
var WEEKDAY_DICTIONARY2 = {
  "sonntag": 0,
  "so": 0,
  "montag": 1,
  "mo": 1,
  "dienstag": 2,
  "di": 2,
  "mittwoch": 3,
  "mi": 3,
  "donnerstag": 4,
  "do": 4,
  "freitag": 5,
  "fr": 5,
  "samstag": 6,
  "sa": 6
};
var MONTH_DICTIONARY2 = {
  "januar": 1,
  "jänner": 1,
  "janner": 1,
  "jan": 1,
  "jan.": 1,
  "februar": 2,
  "feber": 2,
  "feb": 2,
  "feb.": 2,
  "märz": 3,
  "maerz": 3,
  "mär": 3,
  "mär.": 3,
  "mrz": 3,
  "mrz.": 3,
  "april": 4,
  "apr": 4,
  "apr.": 4,
  "mai": 5,
  "juni": 6,
  "jun": 6,
  "jun.": 6,
  "juli": 7,
  "jul": 7,
  "jul.": 7,
  "august": 8,
  "aug": 8,
  "aug.": 8,
  "september": 9,
  "sep": 9,
  "sep.": 9,
  "sept": 9,
  "sept.": 9,
  "oktober": 10,
  "okt": 10,
  "okt.": 10,
  "november": 11,
  "nov": 11,
  "nov.": 11,
  "dezember": 12,
  "dez": 12,
  "dez.": 12
};
var INTEGER_WORD_DICTIONARY2 = {
  "eins": 1,
  "eine": 1,
  "einem": 1,
  "einen": 1,
  "einer": 1,
  "zwei": 2,
  "drei": 3,
  "vier": 4,
  "fünf": 5,
  "fuenf": 5,
  "sechs": 6,
  "sieben": 7,
  "acht": 8,
  "neun": 9,
  "zehn": 10,
  "elf": 11,
  "zwölf": 12,
  "zwoelf": 12
};
var TIME_UNIT_DICTIONARY2 = {
  sek: "second",
  sekunde: "second",
  sekunden: "second",
  min: "minute",
  minute: "minute",
  minuten: "minute",
  h: "hour",
  std: "hour",
  stunde: "hour",
  stunden: "hour",
  tag: "day",
  tage: "day",
  tagen: "day",
  woche: "week",
  wochen: "week",
  monat: "month",
  monate: "month",
  monaten: "month",
  monats: "month",
  quartal: "quarter",
  quartals: "quarter",
  quartale: "quarter",
  quartalen: "quarter",
  a: "year",
  j: "year",
  jr: "year",
  jahr: "year",
  jahre: "year",
  jahren: "year",
  jahres: "year"
};
var NUMBER_PATTERN2 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY2)}|[0-9]+|[0-9]+\\.[0-9]+|halb?|halbe?|einigen?|wenigen?|mehreren?)`;
function parseNumberPattern2(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY2[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY2[num];
  } else if (num === "ein" || num === "einer" || num === "einem" || num === "einen" || num === "eine") {
    return 1;
  } else if (num.match(/wenigen/)) {
    return 2;
  } else if (num.match(/halb/) || num.match(/halben/)) {
    return 0.5;
  } else if (num.match(/einigen/)) {
    return 3;
  } else if (num.match(/mehreren/)) {
    return 7;
  }
  return parseFloat(num);
}
var YEAR_PATTERN2 = `(?:[0-9]{1,4}(?:\\s*[vn]\\.?\\s*(?:C(?:hr)?|(?:u\\.?|d\\.?(?:\\s*g\\.?)?)?\\s*Z)\\.?|\\s*(?:u\\.?|d\\.?(?:\\s*g\\.)?)\\s*Z\\.?)?)`;
function parseYear2(match) {
  if (/v/i.test(match)) {
    return -parseInt(match.replace(/[^0-9]+/gi, ""));
  }
  if (/n/i.test(match)) {
    return parseInt(match.replace(/[^0-9]+/gi, ""));
  }
  if (/z/i.test(match)) {
    return parseInt(match.replace(/[^0-9]+/gi, ""));
  }
  const rawYearNumber = parseInt(match);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN2 = `(${NUMBER_PATTERN2})\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY2)})\\s{0,5}`;
var SINGLE_TIME_UNIT_REGEX2 = new RegExp(SINGLE_TIME_UNIT_PATTERN2, "i");
var TIME_UNITS_PATTERN2 = repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN2);
function parseDuration2(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX2.exec(remainingText);
  while (match) {
    collectDateTimeFragment2(fragments, match);
    remainingText = remainingText.substring(match[0].length);
    match = SINGLE_TIME_UNIT_REGEX2.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment2(fragments, match) {
  const num = parseNumberPattern2(match[1]);
  const unit = TIME_UNIT_DICTIONARY2[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/de/parsers/DEWeekdayParser.js
var PATTERN15 = new RegExp(`(?:(?:\\,|\\(|\\（)\\s*)?(?:a[mn]\\s*?)?(?:(diese[mn]|letzte[mn]|n(?:ä|ae)chste[mn])\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY2)})(?:\\s*(?:\\,|\\)|\\）))?(?:\\s*(diese|letzte|n(?:ä|ae)chste)\\s*woche)?(?=\\W|$)`, "i");
var PREFIX_GROUP3 = 1;
var SUFFIX_GROUP = 3;
var WEEKDAY_GROUP2 = 2;
var DEWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN15;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP2].toLowerCase();
    const offset = WEEKDAY_DICTIONARY2[dayOfWeek];
    const prefix = match[PREFIX_GROUP3];
    const postfix = match[SUFFIX_GROUP];
    let modifierWord = prefix || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord.match(/letzte/)) {
      modifier = "last";
    } else if (modifierWord.match(/chste/)) {
      modifier = "next";
    } else if (modifierWord.match(/diese/)) {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, offset, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DESpecificTimeExpressionParser.js
var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:um|von)\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\–|\\~|\\〜|bis(?:\\s+um)?|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
var HOUR_GROUP2 = 2;
var MINUTE_GROUP2 = 3;
var SECOND_GROUP2 = 4;
var AM_PM_HOUR_GROUP2 = 5;
var DESpecificTimeExpressionParser = class _DESpecificTimeExpressionParser {
  pattern(context) {
    return FIRST_REG_PATTERN;
  }
  extract(context, match) {
    const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
    if (result.text.match(/^\d{4}$/)) {
      match.index += match[0].length;
      return null;
    }
    result.start = _DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
    if (!result.start) {
      match.index += match[0].length;
      return null;
    }
    const remainingText = context.text.substring(match.index + match[0].length);
    const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
    if (secondMatch) {
      result.end = _DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
      if (result.end) {
        result.text += secondMatch[0];
      }
    }
    return result;
  }
  static extractTimeComponent(extractingComponents, match) {
    let hour = 0;
    let minute = 0;
    let meridiem = null;
    hour = parseInt(match[HOUR_GROUP2]);
    if (match[MINUTE_GROUP2] != null) {
      minute = parseInt(match[MINUTE_GROUP2]);
    }
    if (minute >= 60 || hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = Meridiem.PM;
    }
    if (match[AM_PM_HOUR_GROUP2] != null) {
      if (hour > 12)
        return null;
      const ampm = match[AM_PM_HOUR_GROUP2].toLowerCase();
      if (ampm.match(/morgen|vormittag/)) {
        meridiem = Meridiem.AM;
        if (hour == 12) {
          hour = 0;
        }
      }
      if (ampm.match(/nachmittag|abend/)) {
        meridiem = Meridiem.PM;
        if (hour != 12) {
          hour += 12;
        }
      }
      if (ampm.match(/nacht/)) {
        if (hour == 12) {
          meridiem = Meridiem.AM;
          hour = 0;
        } else if (hour < 6) {
          meridiem = Meridiem.AM;
        } else {
          meridiem = Meridiem.PM;
          hour += 12;
        }
      }
    }
    extractingComponents.assign("hour", hour);
    extractingComponents.assign("minute", minute);
    if (meridiem !== null) {
      extractingComponents.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        extractingComponents.imply("meridiem", Meridiem.AM);
      } else {
        extractingComponents.imply("meridiem", Meridiem.PM);
      }
    }
    if (match[SECOND_GROUP2] != null) {
      const second = parseInt(match[SECOND_GROUP2]);
      if (second >= 60)
        return null;
      extractingComponents.assign("second", second);
    }
    return extractingComponents;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/refiners/DEMergeDateRangeRefiner.js
var DEMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(bis(?:\s*(?:am|zum))?|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/refiners/DEMergeDateTimeRefiner.js
var DEMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(T|um|am|,|-)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DECasualTimeParser.js
var DECasualTimeParser = class _DECasualTimeParser extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(diesen)?\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const targetDate = context.refDate;
    const timeKeywordPattern = match[2].toLowerCase();
    const component = context.createParsingComponents();
    implySimilarTime(component, targetDate);
    return _DECasualTimeParser.extractTimeComponents(component, timeKeywordPattern);
  }
  static extractTimeComponents(component, timeKeywordPattern) {
    switch (timeKeywordPattern) {
      case "morgen":
        component.imply("hour", 6);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "vormittag":
        component.imply("hour", 9);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "mittag":
      case "mittags":
        component.imply("hour", 12);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "nachmittag":
        component.imply("hour", 15);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "abend":
        component.imply("hour", 18);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "nacht":
        component.imply("hour", 22);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "mitternacht":
        if (component.get("hour") > 1) {
          component.addDurationAsImplied({ "day": 1 });
        }
        component.imply("hour", 0);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DECasualDateParser.js
var PATTERN16 = new RegExp(`(jetzt|heute|morgen|übermorgen|uebermorgen|gestern|vorgestern|letzte\\s*nacht)(?:\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht))?(?=\\W|$)`, "i");
var DATE_GROUP3 = 1;
var TIME_GROUP = 2;
var DECasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return PATTERN16;
  }
  innerExtract(context, match) {
    let targetDate = context.reference.getDateWithAdjustedTimezone();
    const dateKeyword = (match[DATE_GROUP3] || "").toLowerCase();
    const timeKeyword = (match[TIME_GROUP] || "").toLowerCase();
    let component = context.createParsingComponents();
    switch (dateKeyword) {
      case "jetzt":
        component = now(context.reference);
        break;
      case "heute":
        component = today(context.reference);
        break;
      case "morgen":
        targetDate = addDuration(targetDate, { day: 1 });
        assignSimilarDate(component, targetDate);
        implySimilarTime(component, targetDate);
        break;
      case "übermorgen":
      case "uebermorgen":
        targetDate = addDuration(targetDate, { day: 2 });
        assignSimilarDate(component, targetDate);
        implySimilarTime(component, targetDate);
        break;
      case "gestern":
        targetDate = addDuration(targetDate, { day: -1 });
        assignSimilarDate(component, targetDate);
        implySimilarTime(component, targetDate);
        break;
      case "vorgestern":
        targetDate = addDuration(targetDate, { day: -2 });
        assignSimilarDate(component, targetDate);
        implySimilarTime(component, targetDate);
        break;
      default:
        if (dateKeyword.match(/letzte\s*nacht/)) {
          if (targetDate.getHours() > 6) {
            targetDate = addDuration(targetDate, { day: -1 });
          }
          assignSimilarDate(component, targetDate);
          component.imply("hour", 0);
        }
        break;
    }
    if (timeKeyword) {
      component = DECasualTimeParser.extractTimeComponents(component, timeKeyword);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DEMonthNameLittleEndianParser.js
var PATTERN17 = new RegExp(`(?:am\\s*?)?(?:den\\s*?)?([0-9]{1,2})\\.(?:\\s*(?:bis(?:\\s*(?:am|zum))?|\\-|\\–|\\s)\\s*([0-9]{1,2})\\.?)?\\s*(${matchAnyPattern(MONTH_DICTIONARY2)})(?:(?:-|/|,?\\s*)(${YEAR_PATTERN2}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
var DATE_GROUP4 = 1;
var DATE_TO_GROUP3 = 2;
var MONTH_NAME_GROUP5 = 3;
var YEAR_GROUP7 = 4;
var DEMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN17;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY2[match[MONTH_NAME_GROUP5].toLowerCase()];
    const day = parseInt(match[DATE_GROUP4]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP4].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP7]) {
      const yearNumber = parseYear2(match[YEAR_GROUP7]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP3]) {
      const endDate = parseInt(match[DATE_TO_GROUP3]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DETimeUnitRelativeFormatParser.js
var DETimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor() {
    super();
  }
  innerPattern() {
    return new RegExp(`(?:\\s*((?:nächste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\s*)?(${NUMBER_PATTERN2})?(?:\\s*(nächste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY2)})`, "i");
  }
  innerExtract(context, match) {
    const num = match[2] ? parseNumberPattern2(match[2]) : 1;
    const unit = TIME_UNIT_DICTIONARY2[match[4].toLowerCase()];
    let timeUnits = {};
    timeUnits[unit] = num;
    let modifier = match[1] || match[3] || "";
    modifier = modifier.toLowerCase();
    if (!modifier) {
      return;
    }
    if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {
      timeUnits = reverseDuration(timeUnits);
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DETimeUnitWithinFormatParser.js
var DETimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp(`(?:in|für|während)\\s*(${TIME_UNITS_PATTERN2})(?=\\W|$)`, "i");
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration2(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/de/index.js
var casual2 = new Chrono(createCasualConfiguration());
var strict2 = new Chrono(createConfiguration(true));
function parse2(text, ref, option) {
  return casual2.parse(text, ref, option);
}
function parseDate2(text, ref, option) {
  return casual2.parseDate(text, ref, option);
}
function createCasualConfiguration(littleEndian = true) {
  const option = createConfiguration(false, littleEndian);
  option.parsers.unshift(new DECasualTimeParser());
  option.parsers.unshift(new DECasualDateParser());
  option.parsers.unshift(new DETimeUnitAgoFormatParser());
  return option;
}
function createConfiguration(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new ISOFormatParser(),
      new SlashDateFormatParser(littleEndian),
      new DETimeExpressionParser(),
      new DESpecificTimeExpressionParser(),
      new DEMonthNameLittleEndianParser(),
      new DEWeekdayParser(),
      new DETimeUnitWithinFormatParser()
    ],
    refiners: [new DEMergeDateRangeRefiner(), new DEMergeDateTimeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/fr/index.js
var fr_exports = {};
__export(fr_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual3,
  createCasualConfiguration: () => createCasualConfiguration2,
  createConfiguration: () => createConfiguration2,
  parse: () => parse3,
  parseDate: () => parseDate3,
  strict: () => strict3
});

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRCasualDateParser.js
var FRCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(maintenant|aujourd'hui|demain|hier|cette\s*nuit|la\s*veille)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const targetDate = context.refDate;
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "maintenant":
        return now(context.reference);
      case "aujourd'hui":
        return today(context.reference);
      case "hier":
        return yesterday(context.reference);
      case "demain":
        return tomorrow(context.reference);
      default:
        if (lowerText.match(/cette\s*nuit/)) {
          assignSimilarDate(component, targetDate);
          component.imply("hour", 22);
          component.imply("meridiem", Meridiem.PM);
        } else if (lowerText.match(/la\s*veille/)) {
          const previousDay = new Date(targetDate.getTime());
          previousDay.setDate(previousDay.getDate() - 1);
          assignSimilarDate(component, previousDay);
          component.imply("hour", 0);
        }
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRCasualTimeParser.js
var FRCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(cet?)?\s*(matin|soir|après-midi|aprem|a midi|à minuit)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const suffixLower = match[2].toLowerCase();
    const component = context.createParsingComponents();
    switch (suffixLower) {
      case "après-midi":
      case "aprem":
        component.imply("hour", 14);
        component.imply("minute", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "soir":
        component.imply("hour", 18);
        component.imply("minute", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "matin":
        component.imply("hour", 8);
        component.imply("minute", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "a midi":
        component.imply("hour", 12);
        component.imply("minute", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "à minuit":
        component.imply("hour", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRTimeExpressionParser.js
var FRTimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:[àa])\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\–|\\~|\\〜|[àa]|\\?)\\s*";
  }
  extractPrimaryTimeComponents(context, match) {
    if (match[0].match(/^\s*\d{4}\s*$/)) {
      return null;
    }
    return super.extractPrimaryTimeComponents(context, match);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/refiners/FRMergeDateTimeRefiner.js
var FRMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(T|à|a|au|vers|de|,|-)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/refiners/FRMergeDateRangeRefiner.js
var FRMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(à|a|au|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/constants.js
var WEEKDAY_DICTIONARY3 = {
  "dimanche": 0,
  "dim": 0,
  "lundi": 1,
  "lun": 1,
  "mardi": 2,
  "mar": 2,
  "mercredi": 3,
  "mer": 3,
  "jeudi": 4,
  "jeu": 4,
  "vendredi": 5,
  "ven": 5,
  "samedi": 6,
  "sam": 6
};
var MONTH_DICTIONARY3 = {
  "janvier": 1,
  "jan": 1,
  "jan.": 1,
  "février": 2,
  "fév": 2,
  "fév.": 2,
  "fevrier": 2,
  "fev": 2,
  "fev.": 2,
  "mars": 3,
  "mar": 3,
  "mar.": 3,
  "avril": 4,
  "avr": 4,
  "avr.": 4,
  "mai": 5,
  "juin": 6,
  "jun": 6,
  "juillet": 7,
  "juil": 7,
  "jul": 7,
  "jul.": 7,
  "août": 8,
  "aout": 8,
  "septembre": 9,
  "sep": 9,
  "sep.": 9,
  "sept": 9,
  "sept.": 9,
  "octobre": 10,
  "oct": 10,
  "oct.": 10,
  "novembre": 11,
  "nov": 11,
  "nov.": 11,
  "décembre": 12,
  "decembre": 12,
  "dec": 12,
  "dec.": 12
};
var INTEGER_WORD_DICTIONARY3 = {
  "un": 1,
  "deux": 2,
  "trois": 3,
  "quatre": 4,
  "cinq": 5,
  "six": 6,
  "sept": 7,
  "huit": 8,
  "neuf": 9,
  "dix": 10,
  "onze": 11,
  "douze": 12,
  "treize": 13
};
var TIME_UNIT_DICTIONARY3 = {
  "sec": "second",
  "seconde": "second",
  "secondes": "second",
  "min": "minute",
  "mins": "minute",
  "minute": "minute",
  "minutes": "minute",
  "h": "hour",
  "hr": "hour",
  "hrs": "hour",
  "heure": "hour",
  "heures": "hour",
  "jour": "day",
  "jours": "day",
  "semaine": "week",
  "semaines": "week",
  "mois": "month",
  "trimestre": "quarter",
  "trimestres": "quarter",
  "ans": "year",
  "année": "year",
  "années": "year"
};
var NUMBER_PATTERN3 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY3)}|[0-9]+|[0-9]+\\.[0-9]+|une?\\b|quelques?|demi-?)`;
function parseNumberPattern3(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY3[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY3[num];
  } else if (num === "une" || num === "un") {
    return 1;
  } else if (num.match(/quelques?/)) {
    return 3;
  } else if (num.match(/demi-?/)) {
    return 0.5;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN2 = `(?:[0-9]{1,2}(?:er)?)`;
function parseOrdinalNumberPattern2(match) {
  let num = match.toLowerCase();
  num = num.replace(/(?:er)$/i, "");
  return parseInt(num);
}
var YEAR_PATTERN3 = `(?:[1-9][0-9]{0,3}\\s*(?:AC|AD|p\\.\\s*C(?:hr?)?\\.\\s*n\\.)|[1-2][0-9]{3}|[5-9][0-9])`;
function parseYear3(match) {
  if (/AC/i.test(match)) {
    match = match.replace(/BC/i, "");
    return -parseInt(match);
  }
  if (/AD/i.test(match) || /C/i.test(match)) {
    match = match.replace(/[^\d]+/i, "");
    return parseInt(match);
  }
  let yearNumber = parseInt(match);
  if (yearNumber < 100) {
    if (yearNumber > 50) {
      yearNumber = yearNumber + 1900;
    } else {
      yearNumber = yearNumber + 2e3;
    }
  }
  return yearNumber;
}
var SINGLE_TIME_UNIT_PATTERN3 = `(${NUMBER_PATTERN3})\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY3)})\\s{0,5}`;
var SINGLE_TIME_UNIT_REGEX3 = new RegExp(SINGLE_TIME_UNIT_PATTERN3, "i");
var TIME_UNITS_PATTERN3 = repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN3);
function parseDuration3(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX3.exec(remainingText);
  while (match) {
    collectDateTimeFragment3(fragments, match);
    remainingText = remainingText.substring(match[0].length);
    match = SINGLE_TIME_UNIT_REGEX3.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment3(fragments, match) {
  const num = parseNumberPattern3(match[1]);
  const unit = TIME_UNIT_DICTIONARY3[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRWeekdayParser.js
var PATTERN18 = new RegExp(`(?:(?:\\,|\\(|\\（)\\s*)?(?:(?:ce)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY3)})(?:\\s*(?:\\,|\\)|\\）))?(?:\\s*(dernier|prochain)\\s*)?(?=\\W|\\d|$)`, "i");
var WEEKDAY_GROUP3 = 1;
var POSTFIX_GROUP2 = 2;
var FRWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN18;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP3].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY3[dayOfWeek];
    if (weekday === void 0) {
      return null;
    }
    let suffix = match[POSTFIX_GROUP2];
    suffix = suffix || "";
    suffix = suffix.toLowerCase();
    let modifier = null;
    if (suffix == "dernier") {
      modifier = "last";
    } else if (suffix == "prochain") {
      modifier = "next";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRSpecificTimeExpressionParser.js
var FIRST_REG_PATTERN2 = new RegExp("(^|\\s|T)(?:(?:[àa])\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
var SECOND_REG_PATTERN2 = new RegExp("^\\s*(\\-|\\–|\\~|\\〜|[àa]|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
var HOUR_GROUP3 = 2;
var MINUTE_GROUP3 = 3;
var SECOND_GROUP3 = 4;
var AM_PM_HOUR_GROUP3 = 5;
var FRSpecificTimeExpressionParser = class _FRSpecificTimeExpressionParser {
  pattern(context) {
    return FIRST_REG_PATTERN2;
  }
  extract(context, match) {
    const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));
    if (result.text.match(/^\d{4}$/)) {
      match.index += match[0].length;
      return null;
    }
    result.start = _FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);
    if (!result.start) {
      match.index += match[0].length;
      return null;
    }
    const remainingText = context.text.substring(match.index + match[0].length);
    const secondMatch = SECOND_REG_PATTERN2.exec(remainingText);
    if (secondMatch) {
      result.end = _FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
      if (result.end) {
        result.text += secondMatch[0];
      }
    }
    return result;
  }
  static extractTimeComponent(extractingComponents, match) {
    let hour = 0;
    let minute = 0;
    let meridiem = null;
    hour = parseInt(match[HOUR_GROUP3]);
    if (match[MINUTE_GROUP3] != null) {
      minute = parseInt(match[MINUTE_GROUP3]);
    }
    if (minute >= 60 || hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = Meridiem.PM;
    }
    if (match[AM_PM_HOUR_GROUP3] != null) {
      if (hour > 12)
        return null;
      const ampm = match[AM_PM_HOUR_GROUP3][0].toLowerCase();
      if (ampm == "a") {
        meridiem = Meridiem.AM;
        if (hour == 12) {
          hour = 0;
        }
      }
      if (ampm == "p") {
        meridiem = Meridiem.PM;
        if (hour != 12) {
          hour += 12;
        }
      }
    }
    extractingComponents.assign("hour", hour);
    extractingComponents.assign("minute", minute);
    if (meridiem !== null) {
      extractingComponents.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        extractingComponents.imply("meridiem", Meridiem.AM);
      } else {
        extractingComponents.imply("meridiem", Meridiem.PM);
      }
    }
    if (match[SECOND_GROUP3] != null) {
      const second = parseInt(match[SECOND_GROUP3]);
      if (second >= 60)
        return null;
      extractingComponents.assign("second", second);
    }
    return extractingComponents;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRMonthNameLittleEndianParser.js
var PATTERN19 = new RegExp(`(?:on\\s*?)?(${ORDINAL_NUMBER_PATTERN2})(?:\\s*(?:au|\\-|\\–|jusqu'au?|\\s)\\s*(${ORDINAL_NUMBER_PATTERN2}))?(?:-|/|\\s*(?:de)?\\s*)(${matchAnyPattern(MONTH_DICTIONARY3)})(?:(?:-|/|,?\\s*)(${YEAR_PATTERN3}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
var DATE_GROUP5 = 1;
var DATE_TO_GROUP4 = 2;
var MONTH_NAME_GROUP6 = 3;
var YEAR_GROUP8 = 4;
var FRMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN19;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY3[match[MONTH_NAME_GROUP6].toLowerCase()];
    const day = parseOrdinalNumberPattern2(match[DATE_GROUP5]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP5].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP8]) {
      const yearNumber = parseYear3(match[YEAR_GROUP8]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP4]) {
      const endDate = parseOrdinalNumberPattern2(match[DATE_TO_GROUP4]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRTimeUnitAgoFormatParser.js
var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor() {
    super();
  }
  innerPattern() {
    return new RegExp(`il y a\\s*(${TIME_UNITS_PATTERN3})(?=(?:\\W|$))`, "i");
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration3(match[1]);
    const outputTimeUnits = reverseDuration(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRTimeUnitWithinFormatParser.js
var FRTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp(`(?:dans|en|pour|pendant|de)\\s*(${TIME_UNITS_PATTERN3})(?=\\W|$)`, "i");
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration3(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js
var FRTimeUnitAgoFormatParser2 = class extends AbstractParserWithWordBoundaryChecking {
  constructor() {
    super();
  }
  innerPattern() {
    return new RegExp(`(?:les?|la|l'|du|des?)\\s*(${NUMBER_PATTERN3})?(?:\\s*(prochaine?s?|derni[eè]re?s?|pass[ée]e?s?|pr[ée]c[ée]dents?|suivante?s?))?\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY3)})(?:\\s*(prochaine?s?|derni[eè]re?s?|pass[ée]e?s?|pr[ée]c[ée]dents?|suivante?s?))?`, "i");
  }
  innerExtract(context, match) {
    const num = match[1] ? parseNumberPattern3(match[1]) : 1;
    const unit = TIME_UNIT_DICTIONARY3[match[3].toLowerCase()];
    let timeUnits = {};
    timeUnits[unit] = num;
    let modifier = match[2] || match[4] || "";
    modifier = modifier.toLowerCase();
    if (!modifier) {
      return;
    }
    if (/derni[eè]re?s?/.test(modifier) || /pass[ée]e?s?/.test(modifier) || /pr[ée]c[ée]dents?/.test(modifier)) {
      timeUnits = reverseDuration(timeUnits);
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/index.js
var casual3 = new Chrono(createCasualConfiguration2());
var strict3 = new Chrono(createConfiguration2(true));
function parse3(text, ref, option) {
  return casual3.parse(text, ref, option);
}
function parseDate3(text, ref, option) {
  return casual3.parseDate(text, ref, option);
}
function createCasualConfiguration2(littleEndian = true) {
  const option = createConfiguration2(false, littleEndian);
  option.parsers.unshift(new FRCasualDateParser());
  option.parsers.unshift(new FRCasualTimeParser());
  option.parsers.unshift(new FRTimeUnitAgoFormatParser2());
  return option;
}
function createConfiguration2(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(littleEndian),
      new FRMonthNameLittleEndianParser(),
      new FRTimeExpressionParser(),
      new FRSpecificTimeExpressionParser(),
      new FRTimeUnitAgoFormatParser(),
      new FRTimeUnitWithinFormatParser(),
      new FRWeekdayParser()
    ],
    refiners: [new FRMergeDateTimeRefiner(), new FRMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/ja/index.js
var ja_exports = {};
__export(ja_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual4,
  createCasualConfiguration: () => createCasualConfiguration3,
  createConfiguration: () => createConfiguration3,
  parse: () => parse4,
  parseDate: () => parseDate4,
  strict: () => strict4
});

// node_modules/chrono-node/dist/esm/locales/ja/constants.js
var NUMBER = {
  "零": 0,
  "〇": 0,
  "一": 1,
  "二": 2,
  "三": 3,
  "四": 4,
  "五": 5,
  "六": 6,
  "七": 7,
  "八": 8,
  "九": 9,
  "十": 10
};
var WEEKDAY_OFFSET = {
  "日": 0,
  "月": 1,
  "火": 2,
  "水": 3,
  "木": 4,
  "金": 5,
  "土": 6
};
function toHankaku(text) {
  return String(text).replace(/\u2019/g, "'").replace(/\u201D/g, '"').replace(/\u3000/g, " ").replace(/\uFFE5/g, "¥").replace(/[\uFF01\uFF03-\uFF06\uFF08\uFF09\uFF0C-\uFF19\uFF1C-\uFF1F\uFF21-\uFF3B\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5E]/g, alphaNum);
}
function alphaNum(token) {
  return String.fromCharCode(token.charCodeAt(0) - 65248);
}
function jaStringToNumber(text) {
  let number = 0;
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    if (char === "十") {
      number = number === 0 ? NUMBER[char] : number * NUMBER[char];
    } else {
      number += NUMBER[char];
    }
  }
  return number;
}

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPStandardParser.js
var PATTERN20 = /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\s*)?([0-9０-９]{1,2})月\s*([0-9０-９]{1,2})日/i;
var SPECIAL_YEAR_GROUP = 1;
var TYPICAL_YEAR_GROUP = 2;
var ERA_GROUP = 3;
var YEAR_NUMBER_GROUP3 = 4;
var MONTH_GROUP2 = 5;
var DAY_GROUP = 6;
var JPStandardParser = class {
  pattern() {
    return PATTERN20;
  }
  extract(context, match) {
    const month = parseInt(toHankaku(match[MONTH_GROUP2]));
    const day = parseInt(toHankaku(match[DAY_GROUP]));
    const components = context.createParsingComponents({
      day,
      month
    });
    if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match("同|今|本")) {
      components.assign("year", context.reference.getDateWithAdjustedTimezone().getFullYear());
    }
    if (match[TYPICAL_YEAR_GROUP]) {
      const yearNumText = match[YEAR_NUMBER_GROUP3];
      let year3 = yearNumText == "元" ? 1 : parseInt(toHankaku(yearNumText));
      if (match[ERA_GROUP] == "令和") {
        year3 += 2018;
      } else if (match[ERA_GROUP] == "平成") {
        year3 += 1988;
      } else if (match[ERA_GROUP] == "昭和") {
        year3 += 1925;
      }
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      components.imply("year", year3);
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/refiners/JPMergeDateRangeRefiner.js
var JPMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(から|－|ー|-|～|~)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPCasualDateParser.js
var PATTERN21 = /今日|きょう|本日|ほんじつ|昨日|きのう|明日|あした|今夜|こんや|今夕|こんゆう|今晩|こんばん|今朝|けさ/i;
function normalizeTextToKanji(text) {
  switch (text) {
    case "きょう":
      return "今日";
    case "ほんじつ":
      return "本日";
    case "きのう":
      return "昨日";
    case "あした":
      return "明日";
    case "こんや":
      return "今夜";
    case "こんゆう":
      return "今夕";
    case "こんばん":
      return "今晩";
    case "けさ":
      return "今朝";
    default:
      return text;
  }
}
var JPCasualDateParser = class {
  pattern() {
    return PATTERN21;
  }
  extract(context, match) {
    const text = normalizeTextToKanji(match[0]);
    const components = context.createParsingComponents();
    switch (text) {
      case "昨日":
        return yesterday(context.reference);
      case "明日":
        return tomorrow(context.reference);
      case "本日":
      case "今日":
        return today(context.reference);
    }
    if (text == "今夜" || text == "今夕" || text == "今晩") {
      components.imply("hour", 22);
      components.assign("meridiem", Meridiem.PM);
    } else if (text.match("今朝")) {
      components.imply("hour", 6);
      components.assign("meridiem", Meridiem.AM);
    }
    const date = context.refDate;
    components.assign("day", date.getDate());
    components.assign("month", date.getMonth() + 1);
    components.assign("year", date.getFullYear());
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPWeekdayParser.js
var PATTERN22 = new RegExp("((?<prefix>前の|次の|今週))?(?<weekday>" + Object.keys(WEEKDAY_OFFSET).join("|") + ")(?:曜日|曜)", "i");
var JPWeekdayParser = class {
  pattern() {
    return PATTERN22;
  }
  extract(context, match) {
    const dayOfWeek = match.groups.weekday;
    const offset = WEEKDAY_OFFSET[dayOfWeek];
    if (offset === void 0)
      return null;
    const prefix = match.groups.prefix || "";
    let modifier = null;
    if (prefix.match(/前の/)) {
      modifier = "last";
    } else if (prefix.match(/次の/)) {
      modifier = "next";
    } else if (prefix.match(/今週/)) {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, offset, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPSlashDateFormatParser.js
var PATTERN23 = new RegExp("([0-9０-９]{4}[\\/|\\／])?([0-1０-１]{0,1}[0-9０-９]{1})(?:[\\/|\\／]([0-3０-３]{0,1}[0-9０-９]{1}))", "i");
var YEAR_GROUP9 = 1;
var MONTH_GROUP3 = 2;
var DAY_GROUP2 = 3;
var JPSlashDateFormatParser = class {
  pattern() {
    return PATTERN23;
  }
  extract(context, match) {
    const result = context.createParsingComponents();
    const month = parseInt(toHankaku(match[MONTH_GROUP3]));
    const day = parseInt(toHankaku(match[DAY_GROUP2]));
    if (month < 1 || month > 12) {
      return null;
    }
    if (day < 1 || day > 31) {
      return null;
    }
    result.assign("day", day);
    result.assign("month", month);
    if (match[YEAR_GROUP9]) {
      const rawYearNumber = parseInt(toHankaku(match[YEAR_GROUP9]));
      const year3 = findMostLikelyADYear(rawYearNumber);
      result.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.reference.instant, day, month);
      result.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPTimeExpressionParser.js
var FIRST_REG_PATTERN3 = new RegExp("(?:(午前|午後|A.M.|P.M.|AM|PM))?(?:[\\s,，、]*)(?:([0-9０-９]+|[" + Object.keys(NUMBER).join("") + "]+)(?:\\s*)(?:時(?!間)|:|：)(?:\\s*)([0-9０-９]+|半|[" + Object.keys(NUMBER).join("") + "]+)?(?:\\s*)(?:分|:|：)?(?:\\s*)([0-9０-９]+|[" + Object.keys(NUMBER).join("") + "]+)?(?:\\s*)(?:秒)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var SECOND_REG_PATTERN3 = new RegExp("(?:^\\s*(?:から|\\-|\\–|\\－|\\~|\\〜)\\s*)(?:(午前|午後|A.M.|P.M.|AM|PM))?(?:[\\s,，、]*)(?:([0-9０-９]+|[" + Object.keys(NUMBER).join("") + "]+)(?:\\s*)(?:時|:|：)(?:\\s*)([0-9０-９]+|半|[" + Object.keys(NUMBER).join("") + "]+)?(?:\\s*)(?:分|:|：)?(?:\\s*)([0-9０-９]+|[" + Object.keys(NUMBER).join("") + "]+)?(?:\\s*)(?:秒)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var AM_PM_HOUR_GROUP_1 = 1;
var HOUR_GROUP4 = 2;
var MINUTE_GROUP4 = 3;
var SECOND_GROUP4 = 4;
var AM_PM_HOUR_GROUP_2 = 5;
var JPTimeExpressionParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return FIRST_REG_PATTERN3;
  }
  innerExtract(context, match) {
    if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
      return null;
    }
    const result = context.createParsingResult(match.index, match[0]);
    result.start = createTimeComponents(context, match[HOUR_GROUP4], match[MINUTE_GROUP4], match[SECOND_GROUP4], match[AM_PM_HOUR_GROUP_1] ?? match[AM_PM_HOUR_GROUP_2]);
    if (!result.start) {
      match.index += match[0].length;
      return null;
    }
    match = SECOND_REG_PATTERN3.exec(context.text.substring(result.index + result.text.length));
    if (!match) {
      return result;
    }
    result.text = result.text + match[0];
    result.end = createTimeComponents(context, match[HOUR_GROUP4], match[MINUTE_GROUP4], match[SECOND_GROUP4], match[AM_PM_HOUR_GROUP_1] ?? match[AM_PM_HOUR_GROUP_2]);
    if (!result.end) {
      return null;
    }
    if (!result.end.isCertain("meridiem") && result.start.isCertain("meridiem")) {
      result.end.imply("meridiem", result.start.get("meridiem"));
      if (result.start.get("meridiem") === Meridiem.PM) {
        if (result.start.get("hour") - 12 > result.end.get("hour")) {
          result.end.imply("meridiem", Meridiem.AM);
        } else if (result.end.get("hour") < 12) {
          result.end.assign("hour", result.end.get("hour") + 12);
        }
      }
    }
    if (result.end.date().getTime() < result.start.date().getTime()) {
      result.end.imply("day", result.end.get("day") + 1);
    }
    return result;
  }
};
function createTimeComponents(context, matchHour, matchMinute, matchSecond, matchAmPm) {
  let hour = 0;
  let meridiem = -1;
  let targetComponents = context.createParsingComponents();
  hour = parseInt(toHankaku(matchHour));
  if (isNaN(hour)) {
    hour = jaStringToNumber(matchHour);
  }
  if (hour > 24) {
    return null;
  }
  if (matchMinute) {
    let minute;
    if (matchMinute === "半") {
      minute = 30;
    } else {
      minute = parseInt(toHankaku(matchMinute));
      if (isNaN(minute)) {
        minute = jaStringToNumber(matchMinute);
      }
    }
    if (minute >= 60)
      return null;
    targetComponents.assign("minute", minute);
  }
  if (matchSecond) {
    let second = parseInt(toHankaku(matchSecond));
    if (isNaN(second)) {
      second = jaStringToNumber(matchSecond);
    }
    if (second >= 60)
      return null;
    targetComponents.assign("second", second);
  }
  if (matchAmPm) {
    if (hour > 12) {
      return null;
    }
    const AMPMString = matchAmPm;
    if (AMPMString === "午前" || AMPMString[0].toLowerCase() === "a") {
      meridiem = Meridiem.AM;
      if (hour === 12)
        hour = 0;
    } else if (AMPMString === "午後" || AMPMString[0].toLowerCase() === "p") {
      meridiem = Meridiem.PM;
      if (hour != 12)
        hour += 12;
    }
  }
  targetComponents.assign("hour", hour);
  if (meridiem >= 0) {
    targetComponents.assign("meridiem", meridiem);
  } else {
    if (hour < 12) {
      targetComponents.imply("meridiem", Meridiem.AM);
    } else {
      targetComponents.imply("meridiem", Meridiem.PM);
    }
  }
  return targetComponents;
}

// node_modules/chrono-node/dist/esm/locales/ja/refiners/JPMergeDateTimeRefiner.js
var JPMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return /^\s*(の)?\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/refiners/JPMergeWeekdayComponentRefiner.js
var JPMergeWeekdayComponentRefiner = class extends MergingRefiner {
  mergeResults(textBetween, currentResult, nextResult) {
    const newResult = currentResult.clone();
    newResult.text = currentResult.text + textBetween + nextResult.text;
    newResult.start.assign("weekday", nextResult.start.get("weekday"));
    if (newResult.end) {
      newResult.end.assign("weekday", nextResult.start.get("weekday"));
    }
    return newResult;
  }
  shouldMergeResults(textBetween, currentResult, nextResult) {
    const normalDateThenWeekday = currentResult.start.isCertain("day") && nextResult.start.isOnlyWeekdayComponent() && !nextResult.start.isCertain("hour");
    return normalDateThenWeekday && textBetween.match(/^[,、の]?\s*$/) !== null;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPWeekdayWithParenthesesParser.js
var PATTERN24 = new RegExp("(?:\\(|\\（)(?<weekday>" + Object.keys(WEEKDAY_OFFSET).join("|") + ")(?:\\)|\\）)", "i");
var JPWeekdayWithParenthesesParser = class {
  pattern() {
    return PATTERN24;
  }
  extract(context, match) {
    const dayOfWeek = match.groups.weekday;
    const offset = WEEKDAY_OFFSET[dayOfWeek];
    if (offset === void 0)
      return null;
    return createParsingComponentsAtWeekday(context.reference, offset);
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/index.js
var casual4 = new Chrono(createCasualConfiguration3());
var strict4 = new Chrono(createConfiguration3(true));
function parse4(text, ref, option) {
  return casual4.parse(text, ref, option);
}
function parseDate4(text, ref, option) {
  return casual4.parseDate(text, ref, option);
}
function createCasualConfiguration3() {
  const option = createConfiguration3(false);
  option.parsers.unshift(new JPCasualDateParser());
  return option;
}
function createConfiguration3(strictMode = true) {
  const configuration2 = includeCommonConfiguration({
    parsers: [
      new JPStandardParser(),
      new JPWeekdayParser(),
      new JPWeekdayWithParenthesesParser(),
      new JPSlashDateFormatParser(),
      new JPTimeExpressionParser()
    ],
    refiners: [
      new JPMergeWeekdayComponentRefiner(),
      new JPMergeDateTimeRefiner(),
      new JPMergeDateRangeRefiner()
    ]
  }, strictMode);
  configuration2.refiners = configuration2.refiners.filter((refiner) => !(refiner instanceof MergeWeekdayComponentRefiner));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/locales/pt/index.js
var pt_exports = {};
__export(pt_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual5,
  createCasualConfiguration: () => createCasualConfiguration4,
  createConfiguration: () => createConfiguration4,
  parse: () => parse5,
  parseDate: () => parseDate5,
  strict: () => strict5
});

// node_modules/chrono-node/dist/esm/locales/pt/constants.js
var WEEKDAY_DICTIONARY4 = {
  "domingo": 0,
  "dom": 0,
  "segunda": 1,
  "segunda-feira": 1,
  "seg": 1,
  "terça": 2,
  "terça-feira": 2,
  "ter": 2,
  "quarta": 3,
  "quarta-feira": 3,
  "qua": 3,
  "quinta": 4,
  "quinta-feira": 4,
  "qui": 4,
  "sexta": 5,
  "sexta-feira": 5,
  "sex": 5,
  "sábado": 6,
  "sabado": 6,
  "sab": 6
};
var MONTH_DICTIONARY4 = {
  "janeiro": 1,
  "jan": 1,
  "jan.": 1,
  "fevereiro": 2,
  "fev": 2,
  "fev.": 2,
  "março": 3,
  "mar": 3,
  "mar.": 3,
  "abril": 4,
  "abr": 4,
  "abr.": 4,
  "maio": 5,
  "mai": 5,
  "mai.": 5,
  "junho": 6,
  "jun": 6,
  "jun.": 6,
  "julho": 7,
  "jul": 7,
  "jul.": 7,
  "agosto": 8,
  "ago": 8,
  "ago.": 8,
  "setembro": 9,
  "set": 9,
  "set.": 9,
  "outubro": 10,
  "out": 10,
  "out.": 10,
  "novembro": 11,
  "nov": 11,
  "nov.": 11,
  "dezembro": 12,
  "dez": 12,
  "dez.": 12
};
var YEAR_PATTERN4 = "[0-9]{1,4}(?![^\\s]\\d)(?:\\s*[a|d]\\.?\\s*c\\.?|\\s*a\\.?\\s*d\\.?)?";
function parseYear4(match) {
  if (match.match(/^[0-9]{1,4}$/)) {
    let yearNumber = parseInt(match);
    if (yearNumber < 100) {
      if (yearNumber > 50) {
        yearNumber = yearNumber + 1900;
      } else {
        yearNumber = yearNumber + 2e3;
      }
    }
    return yearNumber;
  }
  if (match.match(/a\.?\s*c\.?/i)) {
    match = match.replace(/a\.?\s*c\.?/i, "");
    return -parseInt(match);
  }
  return parseInt(match);
}

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTWeekdayParser.js
var PATTERN25 = new RegExp(`(?:(?:\\,|\\(|\\（)\\s*)?(?:(este|esta|passado|pr[oó]ximo)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY4)})(?:\\s*(?:\\,|\\)|\\）))?(?:\\s*(este|esta|passado|pr[óo]ximo)\\s*semana)?(?=\\W|\\d|$)`, "i");
var PREFIX_GROUP4 = 1;
var WEEKDAY_GROUP4 = 2;
var POSTFIX_GROUP3 = 3;
var PTWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN25;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP4].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY4[dayOfWeek];
    if (weekday === void 0) {
      return null;
    }
    const prefix = match[PREFIX_GROUP4];
    const postfix = match[POSTFIX_GROUP3];
    let norm = prefix || postfix || "";
    norm = norm.toLowerCase();
    let modifier = null;
    if (norm == "passado") {
      modifier = "this";
    } else if (norm == "próximo" || norm == "proximo") {
      modifier = "next";
    } else if (norm == "este") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTTimeExpressionParser.js
var PTTimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:ao?|às?|das|da|de|do)\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\–|\\~|\\〜|a(?:o)?|\\?)\\s*";
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/refiners/PTMergeDateTimeRefiner.js
var PTMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(?:,|à)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/refiners/PTMergeDateRangeRefiner.js
var PTMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(?:-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTMonthNameLittleEndianParser.js
var PATTERN26 = new RegExp(`([0-9]{1,2})(?:º|ª|°)?(?:\\s*(?:desde|de|\\-|\\–|ao?|\\s)\\s*([0-9]{1,2})(?:º|ª|°)?)?\\s*(?:de)?\\s*(?:-|/|\\s*(?:de|,)?\\s*)(${matchAnyPattern(MONTH_DICTIONARY4)})(?:\\s*(?:de|,)?\\s*(${YEAR_PATTERN4}))?(?=\\W|$)`, "i");
var DATE_GROUP6 = 1;
var DATE_TO_GROUP5 = 2;
var MONTH_NAME_GROUP7 = 3;
var YEAR_GROUP10 = 4;
var PTMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN26;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY4[match[MONTH_NAME_GROUP7].toLowerCase()];
    const day = parseInt(match[DATE_GROUP6]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP6].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP10]) {
      const yearNumber = parseYear4(match[YEAR_GROUP10]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP5]) {
      const endDate = parseInt(match[DATE_TO_GROUP5]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTCasualDateParser.js
var PTCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(agora|hoje|amanha|amanhã|ontem)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "agora":
        return now(context.reference);
      case "hoje":
        return today(context.reference);
      case "amanha":
      case "amanhã":
        return tomorrow(context.reference);
      case "ontem":
        return yesterday(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTCasualTimeParser.js
var PTCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return /(?:esta\s*)?(manha|manhã|tarde|meia-noite|meio-dia|noite)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const targetDate = context.refDate;
    const component = context.createParsingComponents();
    switch (match[1].toLowerCase()) {
      case "tarde":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 15);
        break;
      case "noite":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 22);
        break;
      case "manha":
      case "manhã":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 6);
        break;
      case "meia-noite":
        const nextDay = new Date(targetDate.getTime());
        nextDay.setDate(nextDay.getDate() + 1);
        assignSimilarDate(component, nextDay);
        implySimilarTime(component, nextDay);
        component.imply("hour", 0);
        component.imply("minute", 0);
        component.imply("second", 0);
        break;
      case "meio-dia":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 12);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/index.js
var casual5 = new Chrono(createCasualConfiguration4());
var strict5 = new Chrono(createConfiguration4(true));
function parse5(text, ref, option) {
  return casual5.parse(text, ref, option);
}
function parseDate5(text, ref, option) {
  return casual5.parseDate(text, ref, option);
}
function createCasualConfiguration4(littleEndian = true) {
  const option = createConfiguration4(false, littleEndian);
  option.parsers.push(new PTCasualDateParser());
  option.parsers.push(new PTCasualTimeParser());
  return option;
}
function createConfiguration4(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(littleEndian),
      new PTWeekdayParser(),
      new PTTimeExpressionParser(),
      new PTMonthNameLittleEndianParser()
    ],
    refiners: [new PTMergeDateTimeRefiner(), new PTMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/nl/index.js
var nl_exports = {};
__export(nl_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual6,
  createCasualConfiguration: () => createCasualConfiguration5,
  createConfiguration: () => createConfiguration5,
  parse: () => parse6,
  parseDate: () => parseDate6,
  strict: () => strict6
});

// node_modules/chrono-node/dist/esm/locales/nl/refiners/NLMergeDateRangeRefiner.js
var NLMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(tot|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/refiners/NLMergeDateTimeRefiner.js
var NLMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(om|na|voor|in de|,|-)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLCasualDateParser.js
var NLCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(nu|vandaag|morgen|morgend|gisteren)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "nu":
        return now(context.reference);
      case "vandaag":
        return today(context.reference);
      case "morgen":
      case "morgend":
        return tomorrow(context.reference);
      case "gisteren":
        return yesterday(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLCasualTimeParser.js
var DAY_GROUP3 = 1;
var MOMENT_GROUP = 2;
var NLCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return /(deze)?\s*(namiddag|avond|middernacht|ochtend|middag|'s middags|'s avonds|'s ochtends)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const targetDate = context.refDate;
    const component = context.createParsingComponents();
    if (match[DAY_GROUP3] === "deze") {
      component.assign("day", context.refDate.getDate());
      component.assign("month", context.refDate.getMonth() + 1);
      component.assign("year", context.refDate.getFullYear());
    }
    switch (match[MOMENT_GROUP].toLowerCase()) {
      case "namiddag":
      case "'s namiddags":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 15);
        break;
      case "avond":
      case "'s avonds'":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 20);
        break;
      case "middernacht":
        const nextDay = new Date(targetDate.getTime());
        nextDay.setDate(nextDay.getDate() + 1);
        assignSimilarDate(component, nextDay);
        implySimilarTime(component, nextDay);
        component.imply("hour", 0);
        component.imply("minute", 0);
        component.imply("second", 0);
        break;
      case "ochtend":
      case "'s ochtends":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 6);
        break;
      case "middag":
      case "'s middags":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 12);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/constants.js
var WEEKDAY_DICTIONARY5 = {
  zondag: 0,
  zon: 0,
  "zon.": 0,
  zo: 0,
  "zo.": 0,
  maandag: 1,
  ma: 1,
  "ma.": 1,
  dinsdag: 2,
  din: 2,
  "din.": 2,
  di: 2,
  "di.": 2,
  woensdag: 3,
  woe: 3,
  "woe.": 3,
  wo: 3,
  "wo.": 3,
  donderdag: 4,
  dond: 4,
  "dond.": 4,
  do: 4,
  "do.": 4,
  vrijdag: 5,
  vrij: 5,
  "vrij.": 5,
  vr: 5,
  "vr.": 5,
  zaterdag: 6,
  zat: 6,
  "zat.": 6,
  "za": 6,
  "za.": 6
};
var MONTH_DICTIONARY5 = {
  januari: 1,
  jan: 1,
  "jan.": 1,
  februari: 2,
  feb: 2,
  "feb.": 2,
  maart: 3,
  mar: 3,
  "mar.": 3,
  mrt: 3,
  "mrt.": 3,
  april: 4,
  apr: 4,
  "apr.": 4,
  mei: 5,
  juni: 6,
  jun: 6,
  "jun.": 6,
  juli: 7,
  jul: 7,
  "jul.": 7,
  augustus: 8,
  aug: 8,
  "aug.": 8,
  september: 9,
  sep: 9,
  "sep.": 9,
  sept: 9,
  "sept.": 9,
  oktober: 10,
  okt: 10,
  "okt.": 10,
  november: 11,
  nov: 11,
  "nov.": 11,
  december: 12,
  dec: 12,
  "dec.": 12
};
var INTEGER_WORD_DICTIONARY4 = {
  een: 1,
  twee: 2,
  drie: 3,
  vier: 4,
  vijf: 5,
  zes: 6,
  zeven: 7,
  acht: 8,
  negen: 9,
  tien: 10,
  elf: 11,
  twaalf: 12
};
var ORDINAL_WORD_DICTIONARY2 = {
  eerste: 1,
  tweede: 2,
  derde: 3,
  vierde: 4,
  vijfde: 5,
  zesde: 6,
  zevende: 7,
  achtste: 8,
  negende: 9,
  tiende: 10,
  elfde: 11,
  twaalfde: 12,
  dertiende: 13,
  veertiende: 14,
  vijftiende: 15,
  zestiende: 16,
  zeventiende: 17,
  achttiende: 18,
  negentiende: 19,
  twintigste: 20,
  "eenentwintigste": 21,
  "tweeëntwintigste": 22,
  "drieentwintigste": 23,
  "vierentwintigste": 24,
  "vijfentwintigste": 25,
  "zesentwintigste": 26,
  "zevenentwintigste": 27,
  "achtentwintig": 28,
  "negenentwintig": 29,
  "dertigste": 30,
  "eenendertigste": 31
};
var TIME_UNIT_DICTIONARY4 = {
  sec: "second",
  second: "second",
  seconden: "second",
  min: "minute",
  mins: "minute",
  minute: "minute",
  minuut: "minute",
  minuten: "minute",
  minuutje: "minute",
  h: "hour",
  hr: "hour",
  hrs: "hour",
  uur: "hour",
  u: "hour",
  uren: "hour",
  dag: "day",
  dagen: "day",
  week: "week",
  weken: "week",
  maand: "month",
  maanden: "month",
  jaar: "year",
  jr: "year",
  jaren: "year"
};
var NUMBER_PATTERN4 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY4)}|[0-9]+|[0-9]+[\\.,][0-9]+|halve?|half|paar)`;
function parseNumberPattern4(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY4[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY4[num];
  } else if (num === "paar") {
    return 2;
  } else if (num === "half" || num.match(/halve?/)) {
    return 0.5;
  }
  return parseFloat(num.replace(",", "."));
}
var ORDINAL_NUMBER_PATTERN3 = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY2)}|[0-9]{1,2}(?:ste|de)?)`;
function parseOrdinalNumberPattern3(match) {
  let num = match.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY2[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY2[num];
  }
  num = num.replace(/(?:ste|de)$/i, "");
  return parseInt(num);
}
var YEAR_PATTERN5 = `(?:[1-9][0-9]{0,3}\\s*(?:voor Christus|na Christus)|[1-2][0-9]{3}|[5-9][0-9])`;
function parseYear5(match) {
  if (/voor Christus/i.test(match)) {
    match = match.replace(/voor Christus/i, "");
    return -parseInt(match);
  }
  if (/na Christus/i.test(match)) {
    match = match.replace(/na Christus/i, "");
    return parseInt(match);
  }
  const rawYearNumber = parseInt(match);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN4 = `(${NUMBER_PATTERN4})\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY4)})\\s{0,5}`;
var SINGLE_TIME_UNIT_REGEX4 = new RegExp(SINGLE_TIME_UNIT_PATTERN4, "i");
var TIME_UNITS_PATTERN4 = repeatedTimeunitPattern(`(?:(?:binnen|in)\\s*)?`, SINGLE_TIME_UNIT_PATTERN4);
function parseDuration4(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX4.exec(remainingText);
  while (match) {
    collectDateTimeFragment4(fragments, match);
    remainingText = remainingText.substring(match[0].length);
    match = SINGLE_TIME_UNIT_REGEX4.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment4(fragments, match) {
  const num = parseNumberPattern4(match[1]);
  const unit = TIME_UNIT_DICTIONARY4[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeUnitWithinFormatParser.js
var NLTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp(`(?:binnen|in|binnen de|voor)\\s*(` + TIME_UNITS_PATTERN4 + `)(?=\\W|$)`, "i");
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration4(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLWeekdayParser.js
var PATTERN27 = new RegExp(`(?:(?:\\,|\\(|\\（)\\s*)?(?:op\\s*?)?(?:(deze|vorige|volgende)\\s*(?:week\\s*)?)?(${matchAnyPattern(WEEKDAY_DICTIONARY5)})(?=\\W|$)`, "i");
var PREFIX_GROUP5 = 1;
var WEEKDAY_GROUP5 = 2;
var POSTFIX_GROUP4 = 3;
var NLWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN27;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP5].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY5[dayOfWeek];
    const prefix = match[PREFIX_GROUP5];
    const postfix = match[POSTFIX_GROUP4];
    let modifierWord = prefix || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord == "vorige") {
      modifier = "last";
    } else if (modifierWord == "volgende") {
      modifier = "next";
    } else if (modifierWord == "deze") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLMonthNameMiddleEndianParser.js
var PATTERN28 = new RegExp(`(?:on\\s*?)?(${ORDINAL_NUMBER_PATTERN3})(?:\\s*(?:tot|\\-|\\–|until|through|till|\\s)\\s*(${ORDINAL_NUMBER_PATTERN3}))?(?:-|/|\\s*(?:of)?\\s*)(` + matchAnyPattern(MONTH_DICTIONARY5) + `)(?:(?:-|/|,?\\s*)(${YEAR_PATTERN5}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
var MONTH_NAME_GROUP8 = 3;
var DATE_GROUP7 = 1;
var DATE_TO_GROUP6 = 2;
var YEAR_GROUP11 = 4;
var NLMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN28;
  }
  innerExtract(context, match) {
    const month = MONTH_DICTIONARY5[match[MONTH_NAME_GROUP8].toLowerCase()];
    const day = parseOrdinalNumberPattern3(match[DATE_GROUP7]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP7].length;
      return null;
    }
    const components = context.createParsingComponents({
      day,
      month
    });
    if (match[YEAR_GROUP11]) {
      const year3 = parseYear5(match[YEAR_GROUP11]);
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      components.imply("year", year3);
    }
    if (!match[DATE_TO_GROUP6]) {
      return components;
    }
    const endDate = parseOrdinalNumberPattern3(match[DATE_TO_GROUP6]);
    const result = context.createParsingResult(match.index, match[0]);
    result.start = components;
    result.end = components.clone();
    result.end.assign("day", endDate);
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLMonthNameParser.js
var PATTERN29 = new RegExp(`(${matchAnyPattern(MONTH_DICTIONARY5)})\\s*(?:[,-]?\\s*(${YEAR_PATTERN5})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
var MONTH_NAME_GROUP9 = 1;
var YEAR_GROUP12 = 2;
var NLMonthNameParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN29;
  }
  innerExtract(context, match) {
    const components = context.createParsingComponents();
    components.imply("day", 1);
    const monthName = match[MONTH_NAME_GROUP9];
    const month = MONTH_DICTIONARY5[monthName.toLowerCase()];
    components.assign("month", month);
    if (match[YEAR_GROUP12]) {
      const year3 = parseYear5(match[YEAR_GROUP12]);
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, 1, month);
      components.imply("year", year3);
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLSlashMonthFormatParser.js
var PATTERN30 = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
var MONTH_GROUP4 = 1;
var YEAR_GROUP13 = 2;
var NLSlashMonthFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN30;
  }
  innerExtract(context, match) {
    const year3 = parseInt(match[YEAR_GROUP13]);
    const month = parseInt(match[MONTH_GROUP4]);
    return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year3);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeExpressionParser.js
var NLTimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:om)\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\–|\\~|\\〜|om|\\?)\\s*";
  }
  primarySuffix() {
    return "(?:\\s*(?:uur))?(?!/)(?=\\W|$)";
  }
  extractPrimaryTimeComponents(context, match) {
    if (match[0].match(/^\s*\d{4}\s*$/)) {
      return null;
    }
    return super.extractPrimaryTimeComponents(context, match);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLCasualYearMonthDayParser.js
var PATTERN31 = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${matchAnyPattern(MONTH_DICTIONARY5)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
var YEAR_NUMBER_GROUP4 = 1;
var MONTH_NAME_GROUP10 = 2;
var MONTH_NUMBER_GROUP3 = 3;
var DATE_NUMBER_GROUP3 = 4;
var NLCasualYearMonthDayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN31;
  }
  innerExtract(context, match) {
    const month = match[MONTH_NUMBER_GROUP3] ? parseInt(match[MONTH_NUMBER_GROUP3]) : MONTH_DICTIONARY5[match[MONTH_NAME_GROUP10].toLowerCase()];
    if (month < 1 || month > 12) {
      return null;
    }
    const year3 = parseInt(match[YEAR_NUMBER_GROUP4]);
    const day = parseInt(match[DATE_NUMBER_GROUP3]);
    return {
      day,
      month,
      year: year3
    };
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLCasualDateTimeParser.js
var DATE_GROUP8 = 1;
var TIME_OF_DAY_GROUP = 2;
var NLCasualDateTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(gisteren|morgen|van)(ochtend|middag|namiddag|avond|nacht)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const dateText = match[DATE_GROUP8].toLowerCase();
    const timeText = match[TIME_OF_DAY_GROUP].toLowerCase();
    const component = context.createParsingComponents();
    const targetDate = context.refDate;
    switch (dateText) {
      case "gisteren":
        const previousDay = new Date(targetDate.getTime());
        previousDay.setDate(previousDay.getDate() - 1);
        assignSimilarDate(component, previousDay);
        break;
      case "van":
        assignSimilarDate(component, targetDate);
        break;
      case "morgen":
        const nextDay = new Date(targetDate.getTime());
        nextDay.setDate(nextDay.getDate() + 1);
        assignSimilarDate(component, nextDay);
        implySimilarTime(component, nextDay);
        break;
    }
    switch (timeText) {
      case "ochtend":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 6);
        break;
      case "middag":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 12);
        break;
      case "namiddag":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 15);
        break;
      case "avond":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 20);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js
var PATTERN32 = new RegExp(`(dit|deze|vorig|afgelopen|(?:aan)?komend|over|\\+|-)e?\\s*(${TIME_UNITS_PATTERN4})(?=\\W|$)`, "i");
var PREFIX_WORD_GROUP = 1;
var TIME_UNIT_WORD_GROUP = 2;
var NLTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN32;
  }
  innerExtract(context, match) {
    const prefix = match[PREFIX_WORD_GROUP].toLowerCase();
    let timeUnits = parseDuration4(match[TIME_UNIT_WORD_GROUP]);
    switch (prefix) {
      case "vorig":
      case "afgelopen":
      case "-":
        timeUnits = reverseDuration(timeUnits);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLRelativeDateFormatParser.js
var PATTERN33 = new RegExp(`(dit|deze|(?:aan)?komend|volgend|afgelopen|vorig)e?\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY4)})(?=\\s*)(?=\\W|$)`, "i");
var MODIFIER_WORD_GROUP2 = 1;
var RELATIVE_WORD_GROUP2 = 2;
var NLRelativeDateFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN33;
  }
  innerExtract(context, match) {
    const modifier = match[MODIFIER_WORD_GROUP2].toLowerCase();
    const unitWord = match[RELATIVE_WORD_GROUP2].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY4[unitWord];
    if (modifier == "volgend" || modifier == "komend" || modifier == "aankomend") {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "afgelopen" || modifier == "vorig") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = new Date(context.reference.instant.getTime());
    if (unitWord.match(/week/i)) {
      date.setDate(date.getDate() - date.getDay());
      components.imply("day", date.getDate());
      components.imply("month", date.getMonth() + 1);
      components.imply("year", date.getFullYear());
    } else if (unitWord.match(/maand/i)) {
      date.setDate(1);
      components.imply("day", date.getDate());
      components.assign("year", date.getFullYear());
      components.assign("month", date.getMonth() + 1);
    } else if (unitWord.match(/jaar/i)) {
      date.setDate(1);
      date.setMonth(0);
      components.imply("day", date.getDate());
      components.imply("month", date.getMonth() + 1);
      components.assign("year", date.getFullYear());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeUnitAgoFormatParser.js
var PATTERN34 = new RegExp("(" + TIME_UNITS_PATTERN4 + ")(?:geleden|voor|eerder)(?=(?:\\W|$))", "i");
var STRICT_PATTERN3 = new RegExp("(" + TIME_UNITS_PATTERN4 + ")geleden(?=(?:\\W|$))", "i");
var NLTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMode) {
    super();
    __publicField(this, "strictMode");
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN3 : PATTERN34;
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration4(match[1]);
    const outputTimeUnits = reverseDuration(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeUnitLaterFormatParser.js
var PATTERN35 = new RegExp("(" + TIME_UNITS_PATTERN4 + ")(later|na|vanaf nu|voortaan|vooruit|uit)(?=(?:\\W|$))", "i");
var STRICT_PATTERN4 = new RegExp("(" + TIME_UNITS_PATTERN4 + ")(later|vanaf nu)(?=(?:\\W|$))", "i");
var GROUP_NUM_TIMEUNITS2 = 1;
var NLTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMode) {
    super();
    __publicField(this, "strictMode");
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN4 : PATTERN35;
  }
  innerExtract(context, match) {
    const fragments = parseDuration4(match[GROUP_NUM_TIMEUNITS2]);
    return ParsingComponents.createRelativeFromReference(context.reference, fragments);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/index.js
var casual6 = new Chrono(createCasualConfiguration5());
var strict6 = new Chrono(createConfiguration5(true));
function parse6(text, ref, option) {
  return casual6.parse(text, ref, option);
}
function parseDate6(text, ref, option) {
  return casual6.parseDate(text, ref, option);
}
function createCasualConfiguration5(littleEndian = true) {
  const option = createConfiguration5(false, littleEndian);
  option.parsers.unshift(new NLCasualDateParser());
  option.parsers.unshift(new NLCasualTimeParser());
  option.parsers.unshift(new NLCasualDateTimeParser());
  option.parsers.unshift(new NLMonthNameParser());
  option.parsers.unshift(new NLRelativeDateFormatParser());
  option.parsers.unshift(new NLTimeUnitCasualRelativeFormatParser());
  return option;
}
function createConfiguration5(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(littleEndian),
      new NLTimeUnitWithinFormatParser(),
      new NLMonthNameMiddleEndianParser(),
      new NLMonthNameParser(),
      new NLWeekdayParser(),
      new NLCasualYearMonthDayParser(),
      new NLSlashMonthFormatParser(),
      new NLTimeExpressionParser(strictMode),
      new NLTimeUnitAgoFormatParser(strictMode),
      new NLTimeUnitLaterFormatParser(strictMode)
    ],
    refiners: [new NLMergeDateTimeRefiner(), new NLMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/zh/index.js
var zh_exports = {};
__export(zh_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual9,
  createCasualConfiguration: () => createCasualConfiguration8,
  createConfiguration: () => createConfiguration8,
  hans: () => hans_exports,
  hant: () => hant_exports,
  parse: () => parse9,
  parseDate: () => parseDate9,
  strict: () => strict9
});

// node_modules/chrono-node/dist/esm/locales/zh/hans/constants.js
var NUMBER2 = {
  "零": 0,
  "〇": 0,
  "一": 1,
  "二": 2,
  "两": 2,
  "三": 3,
  "四": 4,
  "五": 5,
  "六": 6,
  "七": 7,
  "八": 8,
  "九": 9,
  "十": 10
};
var WEEKDAY_OFFSET2 = {
  "天": 0,
  "日": 0,
  "一": 1,
  "二": 2,
  "三": 3,
  "四": 4,
  "五": 5,
  "六": 6
};
function zhStringToNumber(text) {
  let number = 0;
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    if (char === "十") {
      number = number === 0 ? NUMBER2[char] : number * NUMBER2[char];
    } else {
      number += NUMBER2[char];
    }
  }
  return number;
}
function zhStringToYear(text) {
  let string = "";
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    string = string + NUMBER2[char];
  }
  return parseInt(string);
}

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansDateParser.js
var YEAR_GROUP14 = 1;
var MONTH_GROUP5 = 2;
var DAY_GROUP4 = 3;
var ZHHansDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp("(\\d{2,4}|[" + Object.keys(NUMBER2).join("") + "]{4}|[" + Object.keys(NUMBER2).join("") + "]{2})?(?:\\s*)(?:年)?(?:[\\s|,|，]*)(\\d{1,2}|[" + Object.keys(NUMBER2).join("") + "]{1,3})(?:\\s*)(?:月)(?:\\s*)(\\d{1,2}|[" + Object.keys(NUMBER2).join("") + "]{1,3})?(?:\\s*)(?:日|号)?");
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    let month = parseInt(match[MONTH_GROUP5]);
    if (isNaN(month))
      month = zhStringToNumber(match[MONTH_GROUP5]);
    result.start.assign("month", month);
    if (match[DAY_GROUP4]) {
      let day = parseInt(match[DAY_GROUP4]);
      if (isNaN(day))
        day = zhStringToNumber(match[DAY_GROUP4]);
      result.start.assign("day", day);
    } else {
      result.start.imply("day", context.refDate.getDate());
    }
    if (match[YEAR_GROUP14]) {
      let year3 = parseInt(match[YEAR_GROUP14]);
      if (isNaN(year3))
        year3 = zhStringToYear(match[YEAR_GROUP14]);
      result.start.assign("year", year3);
    } else {
      result.start.imply("year", context.refDate.getFullYear());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js
var PATTERN36 = new RegExp("(\\d+|[" + Object.keys(NUMBER2).join("") + "]+|半|几)(?:\\s*)(?:个)?(秒(?:钟)?|分钟|小时|钟|日|天|星期|礼拜|月|年)(?:(?:之|过)?后|(?:之)?内)", "i");
var NUMBER_GROUP = 1;
var UNIT_GROUP = 2;
var ZHHansDeadlineFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN36;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    let number = parseInt(match[NUMBER_GROUP]);
    if (isNaN(number)) {
      number = zhStringToNumber(match[NUMBER_GROUP]);
    }
    if (isNaN(number)) {
      const string = match[NUMBER_GROUP];
      if (string === "几") {
        number = 3;
      } else if (string === "半") {
        number = 0.5;
      } else {
        return null;
      }
    }
    const duration = {};
    const unit = match[UNIT_GROUP];
    const unitAbbr = unit[0];
    if (unitAbbr.match(/[日天星礼月年]/)) {
      if (unitAbbr == "日" || unitAbbr == "天") {
        duration.day = number;
      } else if (unitAbbr == "星" || unitAbbr == "礼") {
        duration.week = number;
      } else if (unitAbbr == "月") {
        duration.month = number;
      } else if (unitAbbr == "年") {
        duration.year = number;
      }
      const date2 = addDuration(context.refDate, duration);
      result.start.assign("year", date2.getFullYear());
      result.start.assign("month", date2.getMonth() + 1);
      result.start.assign("day", date2.getDate());
      return result;
    }
    if (unitAbbr == "秒") {
      duration.second = number;
    } else if (unitAbbr == "分") {
      duration.minute = number;
    } else if (unitAbbr == "小" || unitAbbr == "钟") {
      duration.hour = number;
    }
    const date = addDuration(context.refDate, duration);
    result.start.imply("year", date.getFullYear());
    result.start.imply("month", date.getMonth() + 1);
    result.start.imply("day", date.getDate());
    result.start.assign("hour", date.getHours());
    result.start.assign("minute", date.getMinutes());
    result.start.assign("second", date.getSeconds());
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js
var PATTERN37 = new RegExp("(?<prefix>上|下|这)(?:个)?(?:星期|礼拜|周)(?<weekday>" + Object.keys(WEEKDAY_OFFSET2).join("|") + ")");
var ZHHansRelationWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN37;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const dayOfWeek = match.groups.weekday;
    const offset = WEEKDAY_OFFSET2[dayOfWeek];
    if (offset === void 0)
      return null;
    let modifier = null;
    const prefix = match.groups.prefix;
    if (prefix == "上") {
      modifier = "last";
    } else if (prefix == "下") {
      modifier = "next";
    } else if (prefix == "这") {
      modifier = "this";
    }
    const date = new Date(context.refDate.getTime());
    let startMomentFixed = false;
    const refOffset = date.getDay();
    if (modifier == "last" || modifier == "past") {
      date.setDate(date.getDate() + (offset - 7 - refOffset));
      startMomentFixed = true;
    } else if (modifier == "next") {
      date.setDate(date.getDate() + (offset + 7 - refOffset));
      startMomentFixed = true;
    } else if (modifier == "this") {
      date.setDate(date.getDate() + (offset - refOffset));
    } else {
      let diff = offset - refOffset;
      if (Math.abs(diff - 7) < Math.abs(diff)) {
        diff -= 7;
      }
      if (Math.abs(diff + 7) < Math.abs(diff)) {
        diff += 7;
      }
      date.setDate(date.getDate() + diff);
    }
    result.start.assign("weekday", offset);
    if (startMomentFixed) {
      result.start.assign("day", date.getDate());
      result.start.assign("month", date.getMonth() + 1);
      result.start.assign("year", date.getFullYear());
    } else {
      result.start.imply("day", date.getDate());
      result.start.imply("month", date.getMonth() + 1);
      result.start.imply("year", date.getFullYear());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js
var FIRST_REG_PATTERN4 = new RegExp("(?:从|自)?(?:(今|明|前|大前|后|大后|昨)(早|朝|晚)|(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|(今|明|前|大前|后|大后|昨)(?:日|天)(?:[\\s,，]*)(?:(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?)?(?:[\\s,，]*)(?:(\\d+|[" + Object.keys(NUMBER2).join("") + "]+)(?:\\s*)(?:点|时|:|：)(?:\\s*)(\\d+|半|正|整|[" + Object.keys(NUMBER2).join("") + "]+)?(?:\\s*)(?:分|:|：)?(?:\\s*)(\\d+|[" + Object.keys(NUMBER2).join("") + "]+)?(?:\\s*)(?:秒)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var SECOND_REG_PATTERN4 = new RegExp("(?:^\\s*(?:到|至|\\-|\\–|\\~|\\〜)\\s*)(?:(今|明|前|大前|后|大后|昨)(早|朝|晚)|(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|(今|明|前|大前|后|大后|昨)(?:日|天)(?:[\\s,，]*)(?:(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?)?(?:[\\s,，]*)(?:(\\d+|[" + Object.keys(NUMBER2).join("") + "]+)(?:\\s*)(?:点|时|:|：)(?:\\s*)(\\d+|半|正|整|[" + Object.keys(NUMBER2).join("") + "]+)?(?:\\s*)(?:分|:|：)?(?:\\s*)(\\d+|[" + Object.keys(NUMBER2).join("") + "]+)?(?:\\s*)(?:秒)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var DAY_GROUP_1 = 1;
var ZH_AM_PM_HOUR_GROUP_1 = 2;
var ZH_AM_PM_HOUR_GROUP_2 = 3;
var DAY_GROUP_3 = 4;
var ZH_AM_PM_HOUR_GROUP_3 = 5;
var HOUR_GROUP5 = 6;
var MINUTE_GROUP5 = 7;
var SECOND_GROUP5 = 8;
var AM_PM_HOUR_GROUP4 = 9;
var ZHHansTimeExpressionParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return FIRST_REG_PATTERN4;
  }
  innerExtract(context, match) {
    if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
      return null;
    }
    const result = context.createParsingResult(match.index, match[0]);
    const startMoment = new Date(context.refDate.getTime());
    if (match[DAY_GROUP_1]) {
      const day1 = match[DAY_GROUP_1];
      if (day1 == "明") {
        if (context.refDate.getHours() > 1) {
          startMoment.setDate(startMoment.getDate() + 1);
        }
      } else if (day1 == "昨") {
        startMoment.setDate(startMoment.getDate() - 1);
      } else if (day1 == "前") {
        startMoment.setDate(startMoment.getDate() - 2);
      } else if (day1 == "大前") {
        startMoment.setDate(startMoment.getDate() - 3);
      } else if (day1 == "后") {
        startMoment.setDate(startMoment.getDate() + 2);
      } else if (day1 == "大后") {
        startMoment.setDate(startMoment.getDate() + 3);
      }
      result.start.assign("day", startMoment.getDate());
      result.start.assign("month", startMoment.getMonth() + 1);
      result.start.assign("year", startMoment.getFullYear());
    } else if (match[DAY_GROUP_3]) {
      const day3 = match[DAY_GROUP_3];
      if (day3 == "明") {
        startMoment.setDate(startMoment.getDate() + 1);
      } else if (day3 == "昨") {
        startMoment.setDate(startMoment.getDate() - 1);
      } else if (day3 == "前") {
        startMoment.setDate(startMoment.getDate() - 2);
      } else if (day3 == "大前") {
        startMoment.setDate(startMoment.getDate() - 3);
      } else if (day3 == "后") {
        startMoment.setDate(startMoment.getDate() + 2);
      } else if (day3 == "大后") {
        startMoment.setDate(startMoment.getDate() + 3);
      }
      result.start.assign("day", startMoment.getDate());
      result.start.assign("month", startMoment.getMonth() + 1);
      result.start.assign("year", startMoment.getFullYear());
    } else {
      result.start.imply("day", startMoment.getDate());
      result.start.imply("month", startMoment.getMonth() + 1);
      result.start.imply("year", startMoment.getFullYear());
    }
    let hour = 0;
    let minute = 0;
    let meridiem = -1;
    if (match[SECOND_GROUP5]) {
      let second = parseInt(match[SECOND_GROUP5]);
      if (isNaN(second)) {
        second = zhStringToNumber(match[SECOND_GROUP5]);
      }
      if (second >= 60)
        return null;
      result.start.assign("second", second);
    }
    hour = parseInt(match[HOUR_GROUP5]);
    if (isNaN(hour)) {
      hour = zhStringToNumber(match[HOUR_GROUP5]);
    }
    if (match[MINUTE_GROUP5]) {
      if (match[MINUTE_GROUP5] == "半") {
        minute = 30;
      } else if (match[MINUTE_GROUP5] == "正" || match[MINUTE_GROUP5] == "整") {
        minute = 0;
      } else {
        minute = parseInt(match[MINUTE_GROUP5]);
        if (isNaN(minute)) {
          minute = zhStringToNumber(match[MINUTE_GROUP5]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = 1;
    }
    if (match[AM_PM_HOUR_GROUP4]) {
      if (hour > 12)
        return null;
      const ampm = match[AM_PM_HOUR_GROUP4][0].toLowerCase();
      if (ampm == "a") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      }
      if (ampm == "p") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {
      const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];
      const zhAMPM1 = zhAMPMString1[0];
      if (zhAMPM1 == "早") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM1 == "晚") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {
      const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];
      const zhAMPM2 = zhAMPMString2[0];
      if (zhAMPM2 == "上" || zhAMPM2 == "早" || zhAMPM2 == "凌") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM2 == "下" || zhAMPM2 == "晚") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {
      const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];
      const zhAMPM3 = zhAMPMString3[0];
      if (zhAMPM3 == "上" || zhAMPM3 == "早" || zhAMPM3 == "凌") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM3 == "下" || zhAMPM3 == "晚") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    }
    result.start.assign("hour", hour);
    result.start.assign("minute", minute);
    if (meridiem >= 0) {
      result.start.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        result.start.imply("meridiem", 0);
      } else {
        result.start.imply("meridiem", 1);
      }
    }
    const secondMatch = SECOND_REG_PATTERN4.exec(context.text.substring(result.index + result.text.length));
    if (!secondMatch) {
      if (result.text.match(/^\d+$/)) {
        return null;
      }
      return result;
    }
    const endMoment = new Date(startMoment.getTime());
    result.end = context.createParsingComponents();
    if (secondMatch[DAY_GROUP_1]) {
      const day1 = secondMatch[DAY_GROUP_1];
      if (day1 == "明") {
        if (context.refDate.getHours() > 1) {
          endMoment.setDate(endMoment.getDate() + 1);
        }
      } else if (day1 == "昨") {
        endMoment.setDate(endMoment.getDate() - 1);
      } else if (day1 == "前") {
        endMoment.setDate(endMoment.getDate() - 2);
      } else if (day1 == "大前") {
        endMoment.setDate(endMoment.getDate() - 3);
      } else if (day1 == "后") {
        endMoment.setDate(endMoment.getDate() + 2);
      } else if (day1 == "大后") {
        endMoment.setDate(endMoment.getDate() + 3);
      }
      result.end.assign("day", endMoment.getDate());
      result.end.assign("month", endMoment.getMonth() + 1);
      result.end.assign("year", endMoment.getFullYear());
    } else if (secondMatch[DAY_GROUP_3]) {
      const day3 = secondMatch[DAY_GROUP_3];
      if (day3 == "明") {
        endMoment.setDate(endMoment.getDate() + 1);
      } else if (day3 == "昨") {
        endMoment.setDate(endMoment.getDate() - 1);
      } else if (day3 == "前") {
        endMoment.setDate(endMoment.getDate() - 2);
      } else if (day3 == "大前") {
        endMoment.setDate(endMoment.getDate() - 3);
      } else if (day3 == "后") {
        endMoment.setDate(endMoment.getDate() + 2);
      } else if (day3 == "大后") {
        endMoment.setDate(endMoment.getDate() + 3);
      }
      result.end.assign("day", endMoment.getDate());
      result.end.assign("month", endMoment.getMonth() + 1);
      result.end.assign("year", endMoment.getFullYear());
    } else {
      result.end.imply("day", endMoment.getDate());
      result.end.imply("month", endMoment.getMonth() + 1);
      result.end.imply("year", endMoment.getFullYear());
    }
    hour = 0;
    minute = 0;
    meridiem = -1;
    if (secondMatch[SECOND_GROUP5]) {
      let second = parseInt(secondMatch[SECOND_GROUP5]);
      if (isNaN(second)) {
        second = zhStringToNumber(secondMatch[SECOND_GROUP5]);
      }
      if (second >= 60)
        return null;
      result.end.assign("second", second);
    }
    hour = parseInt(secondMatch[HOUR_GROUP5]);
    if (isNaN(hour)) {
      hour = zhStringToNumber(secondMatch[HOUR_GROUP5]);
    }
    if (secondMatch[MINUTE_GROUP5]) {
      if (secondMatch[MINUTE_GROUP5] == "半") {
        minute = 30;
      } else if (secondMatch[MINUTE_GROUP5] == "正" || secondMatch[MINUTE_GROUP5] == "整") {
        minute = 0;
      } else {
        minute = parseInt(secondMatch[MINUTE_GROUP5]);
        if (isNaN(minute)) {
          minute = zhStringToNumber(secondMatch[MINUTE_GROUP5]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = 1;
    }
    if (secondMatch[AM_PM_HOUR_GROUP4]) {
      if (hour > 12)
        return null;
      const ampm = secondMatch[AM_PM_HOUR_GROUP4][0].toLowerCase();
      if (ampm == "a") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      }
      if (ampm == "p") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
      if (!result.start.isCertain("meridiem")) {
        if (meridiem == 0) {
          result.start.imply("meridiem", 0);
          if (result.start.get("hour") == 12) {
            result.start.assign("hour", 0);
          }
        } else {
          result.start.imply("meridiem", 1);
          if (result.start.get("hour") != 12) {
            result.start.assign("hour", result.start.get("hour") + 12);
          }
        }
      }
    } else if (secondMatch[ZH_AM_PM_HOUR_GROUP_1]) {
      const zhAMPMString1 = secondMatch[ZH_AM_PM_HOUR_GROUP_1];
      const zhAMPM1 = zhAMPMString1[0];
      if (zhAMPM1 == "早") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM1 == "晚") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (secondMatch[ZH_AM_PM_HOUR_GROUP_2]) {
      const zhAMPMString2 = secondMatch[ZH_AM_PM_HOUR_GROUP_2];
      const zhAMPM2 = zhAMPMString2[0];
      if (zhAMPM2 == "上" || zhAMPM2 == "早" || zhAMPM2 == "凌") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM2 == "下" || zhAMPM2 == "晚") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (secondMatch[ZH_AM_PM_HOUR_GROUP_3]) {
      const zhAMPMString3 = secondMatch[ZH_AM_PM_HOUR_GROUP_3];
      const zhAMPM3 = zhAMPMString3[0];
      if (zhAMPM3 == "上" || zhAMPM3 == "早" || zhAMPM3 == "凌") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM3 == "下" || zhAMPM3 == "晚") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    }
    result.text = result.text + secondMatch[0];
    result.end.assign("hour", hour);
    result.end.assign("minute", minute);
    if (meridiem >= 0) {
      result.end.assign("meridiem", meridiem);
    } else {
      const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
      if (startAtPM && result.start.get("hour") > hour) {
        result.end.imply("meridiem", 0);
      } else if (hour > 12) {
        result.end.imply("meridiem", 1);
      }
    }
    if (result.end.date().getTime() < result.start.date().getTime()) {
      result.end.imply("day", result.end.get("day") + 1);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansWeekdayParser.js
var PATTERN38 = new RegExp("(?:星期|礼拜|周)(?<weekday>" + Object.keys(WEEKDAY_OFFSET2).join("|") + ")");
var ZHHansWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN38;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const dayOfWeek = match.groups.weekday;
    const offset = WEEKDAY_OFFSET2[dayOfWeek];
    if (offset === void 0)
      return null;
    const date = new Date(context.refDate.getTime());
    const startMomentFixed = false;
    const refOffset = date.getDay();
    let diff = offset - refOffset;
    if (Math.abs(diff - 7) < Math.abs(diff)) {
      diff -= 7;
    }
    if (Math.abs(diff + 7) < Math.abs(diff)) {
      diff += 7;
    }
    date.setDate(date.getDate() + diff);
    result.start.assign("weekday", offset);
    if (startMomentFixed) {
      result.start.assign("day", date.getDate());
      result.start.assign("month", date.getMonth() + 1);
      result.start.assign("year", date.getFullYear());
    } else {
      result.start.imply("day", date.getDate());
      result.start.imply("month", date.getMonth() + 1);
      result.start.imply("year", date.getFullYear());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantCasualDateParser.js
var NOW_GROUP = 1;
var DAY_GROUP_12 = 2;
var TIME_GROUP_1 = 3;
var TIME_GROUP_2 = 4;
var DAY_GROUP_32 = 5;
var TIME_GROUP_3 = 6;
var ZHHantCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return new RegExp("(而家|立(?:刻|即)|即刻)|(今|明|前|大前|後|大後|聽|昨|尋|琴)(早|朝|晚)|(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|(今|明|前|大前|後|大後|聽|昨|尋|琴)(?:日|天)(?:[\\s|,|，]*)(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?", "i");
  }
  innerExtract(context, match) {
    const index = match.index;
    const result = context.createParsingResult(index, match[0]);
    const refDate = context.refDate;
    let date = new Date(refDate.getTime());
    if (match[NOW_GROUP]) {
      result.start.imply("hour", refDate.getHours());
      result.start.imply("minute", refDate.getMinutes());
      result.start.imply("second", refDate.getSeconds());
      result.start.imply("millisecond", refDate.getMilliseconds());
    } else if (match[DAY_GROUP_12]) {
      const day1 = match[DAY_GROUP_12];
      const time1 = match[TIME_GROUP_1];
      if (day1 == "明" || day1 == "聽") {
        if (refDate.getHours() > 1) {
          date.setDate(date.getDate() + 1);
        }
      } else if (day1 == "昨" || day1 == "尋" || day1 == "琴") {
        date.setDate(date.getDate() - 1);
      } else if (day1 == "前") {
        date.setDate(date.getDate() - 2);
      } else if (day1 == "大前") {
        date.setDate(date.getDate() - 3);
      } else if (day1 == "後") {
        date.setDate(date.getDate() + 2);
      } else if (day1 == "大後") {
        date.setDate(date.getDate() + 3);
      }
      if (time1 == "早" || time1 == "朝") {
        result.start.imply("hour", 6);
      } else if (time1 == "晚") {
        result.start.imply("hour", 22);
        result.start.imply("meridiem", 1);
      }
    } else if (match[TIME_GROUP_2]) {
      const timeString2 = match[TIME_GROUP_2];
      const time2 = timeString2[0];
      if (time2 == "早" || time2 == "朝" || time2 == "上") {
        result.start.imply("hour", 6);
      } else if (time2 == "下" || time2 == "晏") {
        result.start.imply("hour", 15);
        result.start.imply("meridiem", 1);
      } else if (time2 == "中") {
        result.start.imply("hour", 12);
        result.start.imply("meridiem", 1);
      } else if (time2 == "夜" || time2 == "晚") {
        result.start.imply("hour", 22);
        result.start.imply("meridiem", 1);
      } else if (time2 == "凌") {
        result.start.imply("hour", 0);
      }
    } else if (match[DAY_GROUP_32]) {
      const day3 = match[DAY_GROUP_32];
      if (day3 == "明" || day3 == "聽") {
        if (refDate.getHours() > 1) {
          date.setDate(date.getDate() + 1);
        }
      } else if (day3 == "昨" || day3 == "尋" || day3 == "琴") {
        date.setDate(date.getDate() - 1);
      } else if (day3 == "前") {
        date.setDate(date.getDate() - 2);
      } else if (day3 == "大前") {
        date.setDate(date.getDate() - 3);
      } else if (day3 == "後") {
        date.setDate(date.getDate() + 2);
      } else if (day3 == "大後") {
        date.setDate(date.getDate() + 3);
      }
      const timeString3 = match[TIME_GROUP_3];
      if (timeString3) {
        const time3 = timeString3[0];
        if (time3 == "早" || time3 == "朝" || time3 == "上") {
          result.start.imply("hour", 6);
        } else if (time3 == "下" || time3 == "晏") {
          result.start.imply("hour", 15);
          result.start.imply("meridiem", 1);
        } else if (time3 == "中") {
          result.start.imply("hour", 12);
          result.start.imply("meridiem", 1);
        } else if (time3 == "夜" || time3 == "晚") {
          result.start.imply("hour", 22);
          result.start.imply("meridiem", 1);
        } else if (time3 == "凌") {
          result.start.imply("hour", 0);
        }
      }
    }
    result.start.assign("day", date.getDate());
    result.start.assign("month", date.getMonth() + 1);
    result.start.assign("year", date.getFullYear());
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/constants.js
var NUMBER3 = {
  "零": 0,
  "一": 1,
  "二": 2,
  "兩": 2,
  "三": 3,
  "四": 4,
  "五": 5,
  "六": 6,
  "七": 7,
  "八": 8,
  "九": 9,
  "十": 10,
  "廿": 20,
  "卅": 30
};
var WEEKDAY_OFFSET3 = {
  "天": 0,
  "日": 0,
  "一": 1,
  "二": 2,
  "三": 3,
  "四": 4,
  "五": 5,
  "六": 6
};
function zhStringToNumber2(text) {
  let number = 0;
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    if (char === "十") {
      number = number === 0 ? NUMBER3[char] : number * NUMBER3[char];
    } else {
      number += NUMBER3[char];
    }
  }
  return number;
}
function zhStringToYear2(text) {
  let string = "";
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    string = string + NUMBER3[char];
  }
  return parseInt(string);
}

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantDateParser.js
var YEAR_GROUP15 = 1;
var MONTH_GROUP6 = 2;
var DAY_GROUP5 = 3;
var ZHHantDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp("(\\d{2,4}|[" + Object.keys(NUMBER3).join("") + "]{4}|[" + Object.keys(NUMBER3).join("") + "]{2})?(?:\\s*)(?:年)?(?:[\\s|,|，]*)(\\d{1,2}|[" + Object.keys(NUMBER3).join("") + "]{1,2})(?:\\s*)(?:月)(?:\\s*)(\\d{1,2}|[" + Object.keys(NUMBER3).join("") + "]{1,2})?(?:\\s*)(?:日|號)?");
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    let month = parseInt(match[MONTH_GROUP6]);
    if (isNaN(month))
      month = zhStringToNumber2(match[MONTH_GROUP6]);
    result.start.assign("month", month);
    if (match[DAY_GROUP5]) {
      let day = parseInt(match[DAY_GROUP5]);
      if (isNaN(day))
        day = zhStringToNumber2(match[DAY_GROUP5]);
      result.start.assign("day", day);
    } else {
      result.start.imply("day", context.refDate.getDate());
    }
    if (match[YEAR_GROUP15]) {
      let year3 = parseInt(match[YEAR_GROUP15]);
      if (isNaN(year3))
        year3 = zhStringToYear2(match[YEAR_GROUP15]);
      result.start.assign("year", year3);
    } else {
      result.start.imply("year", context.refDate.getFullYear());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js
var PATTERN39 = new RegExp("(\\d+|[" + Object.keys(NUMBER3).join("") + "]+|半|幾)(?:\\s*)(?:個)?(秒(?:鐘)?|分鐘|小時|鐘|日|天|星期|禮拜|月|年)(?:(?:之|過)?後|(?:之)?內)", "i");
var NUMBER_GROUP2 = 1;
var UNIT_GROUP2 = 2;
var ZHHantDeadlineFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN39;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    let number = parseInt(match[NUMBER_GROUP2]);
    if (isNaN(number)) {
      number = zhStringToNumber2(match[NUMBER_GROUP2]);
    }
    if (isNaN(number)) {
      const string = match[NUMBER_GROUP2];
      if (string === "幾") {
        number = 3;
      } else if (string === "半") {
        number = 0.5;
      } else {
        return null;
      }
    }
    const duration = {};
    const unit = match[UNIT_GROUP2];
    const unitAbbr = unit[0];
    if (unitAbbr.match(/[日天星禮月年]/)) {
      if (unitAbbr == "日" || unitAbbr == "天") {
        duration.day = number;
      } else if (unitAbbr == "星" || unitAbbr == "禮") {
        duration.week = number;
      } else if (unitAbbr == "月") {
        duration.month = number;
      } else if (unitAbbr == "年") {
        duration.year = number;
      }
      const date2 = addDuration(context.refDate, duration);
      result.start.assign("year", date2.getFullYear());
      result.start.assign("month", date2.getMonth() + 1);
      result.start.assign("day", date2.getDate());
      return result;
    }
    if (unitAbbr == "秒") {
      duration.second = number;
    } else if (unitAbbr == "分") {
      duration.minute = number;
    } else if (unitAbbr == "小" || unitAbbr == "鐘") {
      duration.hour = number;
    }
    const date = addDuration(context.refDate, duration);
    result.start.imply("year", date.getFullYear());
    result.start.imply("month", date.getMonth() + 1);
    result.start.imply("day", date.getDate());
    result.start.assign("hour", date.getHours());
    result.start.assign("minute", date.getMinutes());
    result.start.assign("second", date.getSeconds());
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js
var PATTERN40 = new RegExp("(?<prefix>上|今|下|這|呢)(?:個)?(?:星期|禮拜|週)(?<weekday>" + Object.keys(WEEKDAY_OFFSET3).join("|") + ")");
var ZHHantRelationWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN40;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const dayOfWeek = match.groups.weekday;
    const offset = WEEKDAY_OFFSET3[dayOfWeek];
    if (offset === void 0)
      return null;
    let modifier = null;
    const prefix = match.groups.prefix;
    if (prefix == "上") {
      modifier = "last";
    } else if (prefix == "下") {
      modifier = "next";
    } else if (prefix == "今" || prefix == "這" || prefix == "呢") {
      modifier = "this";
    }
    const date = new Date(context.refDate.getTime());
    let startMomentFixed = false;
    const refOffset = date.getDay();
    if (modifier == "last" || modifier == "past") {
      date.setDate(date.getDate() + (offset - 7 - refOffset));
      startMomentFixed = true;
    } else if (modifier == "next") {
      date.setDate(date.getDate() + (offset + 7 - refOffset));
      startMomentFixed = true;
    } else if (modifier == "this") {
      date.setDate(date.getDate() + (offset - refOffset));
    } else {
      let diff = offset - refOffset;
      if (Math.abs(diff - 7) < Math.abs(diff)) {
        diff -= 7;
      }
      if (Math.abs(diff + 7) < Math.abs(diff)) {
        diff += 7;
      }
      date.setDate(date.getDate() + diff);
    }
    result.start.assign("weekday", offset);
    if (startMomentFixed) {
      result.start.assign("day", date.getDate());
      result.start.assign("month", date.getMonth() + 1);
      result.start.assign("year", date.getFullYear());
    } else {
      result.start.imply("day", date.getDate());
      result.start.imply("month", date.getMonth() + 1);
      result.start.imply("year", date.getFullYear());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js
var FIRST_REG_PATTERN5 = new RegExp("(?:由|從|自)?(?:(今|明|前|大前|後|大後|聽|昨|尋|琴)(早|朝|晚)|(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|(今|明|前|大前|後|大後|聽|昨|尋|琴)(?:日|天)(?:[\\s,，]*)(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?)?(?:[\\s,，]*)(?:(\\d+|[" + Object.keys(NUMBER3).join("") + "]+)(?:\\s*)(?:點|時|:|：)(?:\\s*)(\\d+|半|正|整|[" + Object.keys(NUMBER3).join("") + "]+)?(?:\\s*)(?:分|:|：)?(?:\\s*)(\\d+|[" + Object.keys(NUMBER3).join("") + "]+)?(?:\\s*)(?:秒)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var SECOND_REG_PATTERN5 = new RegExp("(?:^\\s*(?:到|至|\\-|\\–|\\~|\\〜)\\s*)(?:(今|明|前|大前|後|大後|聽|昨|尋|琴)(早|朝|晚)|(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|(今|明|前|大前|後|大後|聽|昨|尋|琴)(?:日|天)(?:[\\s,，]*)(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?)?(?:[\\s,，]*)(?:(\\d+|[" + Object.keys(NUMBER3).join("") + "]+)(?:\\s*)(?:點|時|:|：)(?:\\s*)(\\d+|半|正|整|[" + Object.keys(NUMBER3).join("") + "]+)?(?:\\s*)(?:分|:|：)?(?:\\s*)(\\d+|[" + Object.keys(NUMBER3).join("") + "]+)?(?:\\s*)(?:秒)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var DAY_GROUP_13 = 1;
var ZH_AM_PM_HOUR_GROUP_12 = 2;
var ZH_AM_PM_HOUR_GROUP_22 = 3;
var DAY_GROUP_33 = 4;
var ZH_AM_PM_HOUR_GROUP_32 = 5;
var HOUR_GROUP6 = 6;
var MINUTE_GROUP6 = 7;
var SECOND_GROUP6 = 8;
var AM_PM_HOUR_GROUP5 = 9;
var ZHHantTimeExpressionParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return FIRST_REG_PATTERN5;
  }
  innerExtract(context, match) {
    if (match.index > 0 && context.text[match.index - 1].match(/\w/)) {
      return null;
    }
    const result = context.createParsingResult(match.index, match[0]);
    const startMoment = new Date(context.refDate.getTime());
    if (match[DAY_GROUP_13]) {
      const day1 = match[DAY_GROUP_13];
      if (day1 == "明" || day1 == "聽") {
        if (context.refDate.getHours() > 1) {
          startMoment.setDate(startMoment.getDate() + 1);
        }
      } else if (day1 == "昨" || day1 == "尋" || day1 == "琴") {
        startMoment.setDate(startMoment.getDate() - 1);
      } else if (day1 == "前") {
        startMoment.setDate(startMoment.getDate() - 2);
      } else if (day1 == "大前") {
        startMoment.setDate(startMoment.getDate() - 3);
      } else if (day1 == "後") {
        startMoment.setDate(startMoment.getDate() + 2);
      } else if (day1 == "大後") {
        startMoment.setDate(startMoment.getDate() + 3);
      }
      result.start.assign("day", startMoment.getDate());
      result.start.assign("month", startMoment.getMonth() + 1);
      result.start.assign("year", startMoment.getFullYear());
    } else if (match[DAY_GROUP_33]) {
      const day3 = match[DAY_GROUP_33];
      if (day3 == "明" || day3 == "聽") {
        startMoment.setDate(startMoment.getDate() + 1);
      } else if (day3 == "昨" || day3 == "尋" || day3 == "琴") {
        startMoment.setDate(startMoment.getDate() - 1);
      } else if (day3 == "前") {
        startMoment.setDate(startMoment.getDate() - 2);
      } else if (day3 == "大前") {
        startMoment.setDate(startMoment.getDate() - 3);
      } else if (day3 == "後") {
        startMoment.setDate(startMoment.getDate() + 2);
      } else if (day3 == "大後") {
        startMoment.setDate(startMoment.getDate() + 3);
      }
      result.start.assign("day", startMoment.getDate());
      result.start.assign("month", startMoment.getMonth() + 1);
      result.start.assign("year", startMoment.getFullYear());
    } else {
      result.start.imply("day", startMoment.getDate());
      result.start.imply("month", startMoment.getMonth() + 1);
      result.start.imply("year", startMoment.getFullYear());
    }
    let hour = 0;
    let minute = 0;
    let meridiem = -1;
    if (match[SECOND_GROUP6]) {
      var second = parseInt(match[SECOND_GROUP6]);
      if (isNaN(second)) {
        second = zhStringToNumber2(match[SECOND_GROUP6]);
      }
      if (second >= 60)
        return null;
      result.start.assign("second", second);
    }
    hour = parseInt(match[HOUR_GROUP6]);
    if (isNaN(hour)) {
      hour = zhStringToNumber2(match[HOUR_GROUP6]);
    }
    if (match[MINUTE_GROUP6]) {
      if (match[MINUTE_GROUP6] == "半") {
        minute = 30;
      } else if (match[MINUTE_GROUP6] == "正" || match[MINUTE_GROUP6] == "整") {
        minute = 0;
      } else {
        minute = parseInt(match[MINUTE_GROUP6]);
        if (isNaN(minute)) {
          minute = zhStringToNumber2(match[MINUTE_GROUP6]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = 1;
    }
    if (match[AM_PM_HOUR_GROUP5]) {
      if (hour > 12)
        return null;
      var ampm = match[AM_PM_HOUR_GROUP5][0].toLowerCase();
      if (ampm == "a") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      }
      if (ampm == "p") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_12]) {
      var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_12];
      var zhAMPM1 = zhAMPMString1[0];
      if (zhAMPM1 == "朝" || zhAMPM1 == "早") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM1 == "晚") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_22]) {
      var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_22];
      var zhAMPM2 = zhAMPMString2[0];
      if (zhAMPM2 == "上" || zhAMPM2 == "朝" || zhAMPM2 == "早" || zhAMPM2 == "凌") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM2 == "下" || zhAMPM2 == "晏" || zhAMPM2 == "晚") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match[ZH_AM_PM_HOUR_GROUP_32]) {
      var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_32];
      var zhAMPM3 = zhAMPMString3[0];
      if (zhAMPM3 == "上" || zhAMPM3 == "朝" || zhAMPM3 == "早" || zhAMPM3 == "凌") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM3 == "下" || zhAMPM3 == "晏" || zhAMPM3 == "晚") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    }
    result.start.assign("hour", hour);
    result.start.assign("minute", minute);
    if (meridiem >= 0) {
      result.start.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        result.start.imply("meridiem", 0);
      } else {
        result.start.imply("meridiem", 1);
      }
    }
    const secondMatch = SECOND_REG_PATTERN5.exec(context.text.substring(result.index + result.text.length));
    if (!secondMatch) {
      if (result.text.match(/^\d+$/)) {
        return null;
      }
      return result;
    }
    const endMoment = new Date(startMoment.getTime());
    result.end = context.createParsingComponents();
    if (secondMatch[DAY_GROUP_13]) {
      const day1 = secondMatch[DAY_GROUP_13];
      if (day1 == "明" || day1 == "聽") {
        if (context.refDate.getHours() > 1) {
          endMoment.setDate(endMoment.getDate() + 1);
        }
      } else if (day1 == "昨" || day1 == "尋" || day1 == "琴") {
        endMoment.setDate(endMoment.getDate() - 1);
      } else if (day1 == "前") {
        endMoment.setDate(endMoment.getDate() - 2);
      } else if (day1 == "大前") {
        endMoment.setDate(endMoment.getDate() - 3);
      } else if (day1 == "後") {
        endMoment.setDate(endMoment.getDate() + 2);
      } else if (day1 == "大後") {
        endMoment.setDate(endMoment.getDate() + 3);
      }
      result.end.assign("day", endMoment.getDate());
      result.end.assign("month", endMoment.getMonth() + 1);
      result.end.assign("year", endMoment.getFullYear());
    } else if (secondMatch[DAY_GROUP_33]) {
      const day3 = secondMatch[DAY_GROUP_33];
      if (day3 == "明" || day3 == "聽") {
        endMoment.setDate(endMoment.getDate() + 1);
      } else if (day3 == "昨" || day3 == "尋" || day3 == "琴") {
        endMoment.setDate(endMoment.getDate() - 1);
      } else if (day3 == "前") {
        endMoment.setDate(endMoment.getDate() - 2);
      } else if (day3 == "大前") {
        endMoment.setDate(endMoment.getDate() - 3);
      } else if (day3 == "後") {
        endMoment.setDate(endMoment.getDate() + 2);
      } else if (day3 == "大後") {
        endMoment.setDate(endMoment.getDate() + 3);
      }
      result.end.assign("day", endMoment.getDate());
      result.end.assign("month", endMoment.getMonth() + 1);
      result.end.assign("year", endMoment.getFullYear());
    } else {
      result.end.imply("day", endMoment.getDate());
      result.end.imply("month", endMoment.getMonth() + 1);
      result.end.imply("year", endMoment.getFullYear());
    }
    hour = 0;
    minute = 0;
    meridiem = -1;
    if (secondMatch[SECOND_GROUP6]) {
      let second2 = parseInt(secondMatch[SECOND_GROUP6]);
      if (isNaN(second2)) {
        second2 = zhStringToNumber2(secondMatch[SECOND_GROUP6]);
      }
      if (second2 >= 60)
        return null;
      result.end.assign("second", second2);
    }
    hour = parseInt(secondMatch[HOUR_GROUP6]);
    if (isNaN(hour)) {
      hour = zhStringToNumber2(secondMatch[HOUR_GROUP6]);
    }
    if (secondMatch[MINUTE_GROUP6]) {
      if (secondMatch[MINUTE_GROUP6] == "半") {
        minute = 30;
      } else if (secondMatch[MINUTE_GROUP6] == "正" || secondMatch[MINUTE_GROUP6] == "整") {
        minute = 0;
      } else {
        minute = parseInt(secondMatch[MINUTE_GROUP6]);
        if (isNaN(minute)) {
          minute = zhStringToNumber2(secondMatch[MINUTE_GROUP6]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = 1;
    }
    if (secondMatch[AM_PM_HOUR_GROUP5]) {
      if (hour > 12)
        return null;
      var ampm = secondMatch[AM_PM_HOUR_GROUP5][0].toLowerCase();
      if (ampm == "a") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      }
      if (ampm == "p") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
      if (!result.start.isCertain("meridiem")) {
        if (meridiem == 0) {
          result.start.imply("meridiem", 0);
          if (result.start.get("hour") == 12) {
            result.start.assign("hour", 0);
          }
        } else {
          result.start.imply("meridiem", 1);
          if (result.start.get("hour") != 12) {
            result.start.assign("hour", result.start.get("hour") + 12);
          }
        }
      }
    } else if (secondMatch[ZH_AM_PM_HOUR_GROUP_12]) {
      const zhAMPMString12 = secondMatch[ZH_AM_PM_HOUR_GROUP_12];
      var zhAMPM1 = zhAMPMString12[0];
      if (zhAMPM1 == "朝" || zhAMPM1 == "早") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM1 == "晚") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (secondMatch[ZH_AM_PM_HOUR_GROUP_22]) {
      const zhAMPMString22 = secondMatch[ZH_AM_PM_HOUR_GROUP_22];
      var zhAMPM2 = zhAMPMString22[0];
      if (zhAMPM2 == "上" || zhAMPM2 == "朝" || zhAMPM2 == "早" || zhAMPM2 == "凌") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM2 == "下" || zhAMPM2 == "晏" || zhAMPM2 == "晚") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (secondMatch[ZH_AM_PM_HOUR_GROUP_32]) {
      const zhAMPMString32 = secondMatch[ZH_AM_PM_HOUR_GROUP_32];
      var zhAMPM3 = zhAMPMString32[0];
      if (zhAMPM3 == "上" || zhAMPM3 == "朝" || zhAMPM3 == "早" || zhAMPM3 == "凌") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM3 == "下" || zhAMPM3 == "晏" || zhAMPM3 == "晚") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    }
    result.text = result.text + secondMatch[0];
    result.end.assign("hour", hour);
    result.end.assign("minute", minute);
    if (meridiem >= 0) {
      result.end.assign("meridiem", meridiem);
    } else {
      const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
      if (startAtPM && result.start.get("hour") > hour) {
        result.end.imply("meridiem", 0);
      } else if (hour > 12) {
        result.end.imply("meridiem", 1);
      }
    }
    if (result.end.date().getTime() < result.start.date().getTime()) {
      result.end.imply("day", result.end.get("day") + 1);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantWeekdayParser.js
var PATTERN41 = new RegExp("(?:星期|禮拜|週)(?<weekday>" + Object.keys(WEEKDAY_OFFSET3).join("|") + ")");
var ZHHantWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN41;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const dayOfWeek = match.groups.weekday;
    const offset = WEEKDAY_OFFSET3[dayOfWeek];
    if (offset === void 0)
      return null;
    const date = new Date(context.refDate.getTime());
    const startMomentFixed = false;
    const refOffset = date.getDay();
    let diff = offset - refOffset;
    if (Math.abs(diff - 7) < Math.abs(diff)) {
      diff -= 7;
    }
    if (Math.abs(diff + 7) < Math.abs(diff)) {
      diff += 7;
    }
    date.setDate(date.getDate() + diff);
    result.start.assign("weekday", offset);
    if (startMomentFixed) {
      result.start.assign("day", date.getDate());
      result.start.assign("month", date.getMonth() + 1);
      result.start.assign("year", date.getFullYear());
    } else {
      result.start.imply("day", date.getDate());
      result.start.imply("month", date.getMonth() + 1);
      result.start.imply("year", date.getFullYear());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js
var ZHHantMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(至|到|\-|\~|～|－|ー)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js
var ZHHantMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return /^\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/index.js
var hant_exports = {};
__export(hant_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual7,
  createCasualConfiguration: () => createCasualConfiguration6,
  createConfiguration: () => createConfiguration6,
  hant: () => hant,
  parse: () => parse7,
  parseDate: () => parseDate7,
  strict: () => strict7
});
var hant = new Chrono(createCasualConfiguration6());
var casual7 = new Chrono(createCasualConfiguration6());
var strict7 = new Chrono(createConfiguration6());
function parse7(text, ref, option) {
  return casual7.parse(text, ref, option);
}
function parseDate7(text, ref, option) {
  return casual7.parseDate(text, ref, option);
}
function createCasualConfiguration6() {
  const option = createConfiguration6();
  option.parsers.unshift(new ZHHantCasualDateParser());
  return option;
}
function createConfiguration6() {
  const configuration2 = includeCommonConfiguration({
    parsers: [
      new ZHHantDateParser(),
      new ZHHantRelationWeekdayParser(),
      new ZHHantWeekdayParser(),
      new ZHHantTimeExpressionParser(),
      new ZHHantDeadlineFormatParser()
    ],
    refiners: [new ZHHantMergeDateRangeRefiner(), new ZHHantMergeDateTimeRefiner()]
  });
  configuration2.refiners = configuration2.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/locales/zh/hans/index.js
var hans_exports = {};
__export(hans_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual8,
  createCasualConfiguration: () => createCasualConfiguration7,
  createConfiguration: () => createConfiguration7,
  hans: () => hans,
  parse: () => parse8,
  parseDate: () => parseDate8,
  strict: () => strict8
});

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansCasualDateParser.js
var NOW_GROUP2 = 1;
var DAY_GROUP_14 = 2;
var TIME_GROUP_12 = 3;
var TIME_GROUP_22 = 4;
var DAY_GROUP_34 = 5;
var TIME_GROUP_32 = 6;
var ZHHansCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return new RegExp("(现在|立(?:刻|即)|即刻)|(今|明|前|大前|后|大后|昨)(早|晚)|(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|(今|明|前|大前|后|大后|昨)(?:日|天)(?:[\\s|,|，]*)(?:(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?", "i");
  }
  innerExtract(context, match) {
    const index = match.index;
    const result = context.createParsingResult(index, match[0]);
    const refDate = context.refDate;
    let date = new Date(refDate.getTime());
    if (match[NOW_GROUP2]) {
      result.start.imply("hour", refDate.getHours());
      result.start.imply("minute", refDate.getMinutes());
      result.start.imply("second", refDate.getSeconds());
      result.start.imply("millisecond", refDate.getMilliseconds());
    } else if (match[DAY_GROUP_14]) {
      const day1 = match[DAY_GROUP_14];
      const time1 = match[TIME_GROUP_12];
      if (day1 == "明") {
        if (refDate.getHours() > 1) {
          date.setDate(date.getDate() + 1);
        }
      } else if (day1 == "昨") {
        date.setDate(date.getDate() - 1);
      } else if (day1 == "前") {
        date.setDate(date.getDate() - 2);
      } else if (day1 == "大前") {
        date.setDate(date.getDate() - 3);
      } else if (day1 == "后") {
        date.setDate(date.getDate() + 2);
      } else if (day1 == "大后") {
        date.setDate(date.getDate() + 3);
      }
      if (time1 == "早") {
        result.start.imply("hour", 6);
      } else if (time1 == "晚") {
        result.start.imply("hour", 22);
        result.start.imply("meridiem", 1);
      }
    } else if (match[TIME_GROUP_22]) {
      const timeString2 = match[TIME_GROUP_22];
      const time2 = timeString2[0];
      if (time2 == "早" || time2 == "上") {
        result.start.imply("hour", 6);
      } else if (time2 == "下") {
        result.start.imply("hour", 15);
        result.start.imply("meridiem", 1);
      } else if (time2 == "中") {
        result.start.imply("hour", 12);
        result.start.imply("meridiem", 1);
      } else if (time2 == "夜" || time2 == "晚") {
        result.start.imply("hour", 22);
        result.start.imply("meridiem", 1);
      } else if (time2 == "凌") {
        result.start.imply("hour", 0);
      }
    } else if (match[DAY_GROUP_34]) {
      const day3 = match[DAY_GROUP_34];
      if (day3 == "明") {
        if (refDate.getHours() > 1) {
          date.setDate(date.getDate() + 1);
        }
      } else if (day3 == "昨") {
        date.setDate(date.getDate() - 1);
      } else if (day3 == "前") {
        date.setDate(date.getDate() - 2);
      } else if (day3 == "大前") {
        date.setDate(date.getDate() - 3);
      } else if (day3 == "后") {
        date.setDate(date.getDate() + 2);
      } else if (day3 == "大后") {
        date.setDate(date.getDate() + 3);
      }
      const timeString3 = match[TIME_GROUP_32];
      if (timeString3) {
        const time3 = timeString3[0];
        if (time3 == "早" || time3 == "上") {
          result.start.imply("hour", 6);
        } else if (time3 == "下") {
          result.start.imply("hour", 15);
          result.start.imply("meridiem", 1);
        } else if (time3 == "中") {
          result.start.imply("hour", 12);
          result.start.imply("meridiem", 1);
        } else if (time3 == "夜" || time3 == "晚") {
          result.start.imply("hour", 22);
          result.start.imply("meridiem", 1);
        } else if (time3 == "凌") {
          result.start.imply("hour", 0);
        }
      }
    }
    result.start.assign("day", date.getDate());
    result.start.assign("month", date.getMonth() + 1);
    result.start.assign("year", date.getFullYear());
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js
var ZHHansMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(至|到|-|~|～|－|ー)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js
var ZHHansMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return /^\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/index.js
var hans = new Chrono(createCasualConfiguration7());
var casual8 = new Chrono(createCasualConfiguration7());
var strict8 = new Chrono(createConfiguration7());
function parse8(text, ref, option) {
  return casual8.parse(text, ref, option);
}
function parseDate8(text, ref, option) {
  return casual8.parseDate(text, ref, option);
}
function createCasualConfiguration7() {
  const option = createConfiguration7();
  option.parsers.unshift(new ZHHansCasualDateParser());
  return option;
}
function createConfiguration7() {
  const configuration2 = includeCommonConfiguration({
    parsers: [
      new ZHHansDateParser(),
      new ZHHansRelationWeekdayParser(),
      new ZHHansWeekdayParser(),
      new ZHHansTimeExpressionParser(),
      new ZHHansDeadlineFormatParser()
    ],
    refiners: [new ZHHansMergeDateRangeRefiner(), new ZHHansMergeDateTimeRefiner()]
  });
  configuration2.refiners = configuration2.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/locales/zh/index.js
var casual9 = new Chrono(createCasualConfiguration8());
var strict9 = new Chrono(createConfiguration8());
function parse9(text, ref, option) {
  return casual9.parse(text, ref, option);
}
function parseDate9(text, ref, option) {
  return casual9.parseDate(text, ref, option);
}
function createCasualConfiguration8() {
  const option = createConfiguration8();
  option.parsers.unshift(new ZHHantCasualDateParser());
  return option;
}
function createConfiguration8() {
  const configuration2 = includeCommonConfiguration({
    parsers: [
      new ZHHantDateParser(),
      new ZHHansDateParser(),
      new ZHHantRelationWeekdayParser(),
      new ZHHansRelationWeekdayParser(),
      new ZHHantWeekdayParser(),
      new ZHHansWeekdayParser(),
      new ZHHantTimeExpressionParser(),
      new ZHHansTimeExpressionParser(),
      new ZHHantDeadlineFormatParser(),
      new ZHHansDeadlineFormatParser()
    ],
    refiners: [new ZHHantMergeDateRangeRefiner(), new ZHHantMergeDateTimeRefiner()]
  });
  configuration2.refiners = configuration2.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/locales/ru/index.js
var ru_exports = {};
__export(ru_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual10,
  createCasualConfiguration: () => createCasualConfiguration9,
  createConfiguration: () => createConfiguration9,
  parse: () => parse10,
  parseDate: () => parseDate10,
  strict: () => strict10
});

// node_modules/chrono-node/dist/esm/locales/ru/constants.js
var REGEX_PARTS = {
  leftBoundary: "([^\\p{L}\\p{N}_]|^)",
  rightBoundary: "(?=[^\\p{L}\\p{N}_]|$)",
  flags: "iu"
};
var WEEKDAY_DICTIONARY6 = {
  воскресенье: 0,
  воскресенья: 0,
  вск: 0,
  "вск.": 0,
  понедельник: 1,
  понедельника: 1,
  пн: 1,
  "пн.": 1,
  вторник: 2,
  вторника: 2,
  вт: 2,
  "вт.": 2,
  среда: 3,
  среды: 3,
  среду: 3,
  ср: 3,
  "ср.": 3,
  четверг: 4,
  четверга: 4,
  чт: 4,
  "чт.": 4,
  пятница: 5,
  пятницу: 5,
  пятницы: 5,
  пт: 5,
  "пт.": 5,
  суббота: 6,
  субботу: 6,
  субботы: 6,
  сб: 6,
  "сб.": 6
};
var FULL_MONTH_NAME_DICTIONARY2 = {
  январь: 1,
  января: 1,
  январе: 1,
  февраль: 2,
  февраля: 2,
  феврале: 2,
  март: 3,
  марта: 3,
  марте: 3,
  апрель: 4,
  апреля: 4,
  апреле: 4,
  май: 5,
  мая: 5,
  мае: 5,
  июнь: 6,
  июня: 6,
  июне: 6,
  июль: 7,
  июля: 7,
  июле: 7,
  август: 8,
  августа: 8,
  августе: 8,
  сентябрь: 9,
  сентября: 9,
  сентябре: 9,
  октябрь: 10,
  октября: 10,
  октябре: 10,
  ноябрь: 11,
  ноября: 11,
  ноябре: 11,
  декабрь: 12,
  декабря: 12,
  декабре: 12
};
var MONTH_DICTIONARY6 = {
  ...FULL_MONTH_NAME_DICTIONARY2,
  янв: 1,
  "янв.": 1,
  фев: 2,
  "фев.": 2,
  мар: 3,
  "мар.": 3,
  апр: 4,
  "апр.": 4,
  авг: 8,
  "авг.": 8,
  сен: 9,
  "сен.": 9,
  окт: 10,
  "окт.": 10,
  ноя: 11,
  "ноя.": 11,
  дек: 12,
  "дек.": 12
};
var INTEGER_WORD_DICTIONARY5 = {
  один: 1,
  одна: 1,
  одной: 1,
  одну: 1,
  две: 2,
  два: 2,
  двух: 2,
  три: 3,
  трех: 3,
  трёх: 3,
  четыре: 4,
  четырех: 4,
  четырёх: 4,
  пять: 5,
  пяти: 5,
  шесть: 6,
  шести: 6,
  семь: 7,
  семи: 7,
  восемь: 8,
  восьми: 8,
  девять: 9,
  девяти: 9,
  десять: 10,
  десяти: 10,
  одиннадцать: 11,
  одиннадцати: 11,
  двенадцать: 12,
  двенадцати: 12
};
var ORDINAL_WORD_DICTIONARY3 = {
  первое: 1,
  первого: 1,
  второе: 2,
  второго: 2,
  третье: 3,
  третьего: 3,
  четвертое: 4,
  четвертого: 4,
  пятое: 5,
  пятого: 5,
  шестое: 6,
  шестого: 6,
  седьмое: 7,
  седьмого: 7,
  восьмое: 8,
  восьмого: 8,
  девятое: 9,
  девятого: 9,
  десятое: 10,
  десятого: 10,
  одиннадцатое: 11,
  одиннадцатого: 11,
  двенадцатое: 12,
  двенадцатого: 12,
  тринадцатое: 13,
  тринадцатого: 13,
  четырнадцатое: 14,
  четырнадцатого: 14,
  пятнадцатое: 15,
  пятнадцатого: 15,
  шестнадцатое: 16,
  шестнадцатого: 16,
  семнадцатое: 17,
  семнадцатого: 17,
  восемнадцатое: 18,
  восемнадцатого: 18,
  девятнадцатое: 19,
  девятнадцатого: 19,
  двадцатое: 20,
  двадцатого: 20,
  "двадцать первое": 21,
  "двадцать первого": 21,
  "двадцать второе": 22,
  "двадцать второго": 22,
  "двадцать третье": 23,
  "двадцать третьего": 23,
  "двадцать четвертое": 24,
  "двадцать четвертого": 24,
  "двадцать пятое": 25,
  "двадцать пятого": 25,
  "двадцать шестое": 26,
  "двадцать шестого": 26,
  "двадцать седьмое": 27,
  "двадцать седьмого": 27,
  "двадцать восьмое": 28,
  "двадцать восьмого": 28,
  "двадцать девятое": 29,
  "двадцать девятого": 29,
  "тридцатое": 30,
  "тридцатого": 30,
  "тридцать первое": 31,
  "тридцать первого": 31
};
var TIME_UNIT_DICTIONARY5 = {
  сек: "second",
  секунда: "second",
  секунд: "second",
  секунды: "second",
  секунду: "second",
  секундочка: "second",
  секундочки: "second",
  секундочек: "second",
  секундочку: "second",
  мин: "minute",
  минута: "minute",
  минут: "minute",
  минуты: "minute",
  минуту: "minute",
  минуток: "minute",
  минутки: "minute",
  минутку: "minute",
  минуточек: "minute",
  минуточки: "minute",
  минуточку: "minute",
  час: "hour",
  часов: "hour",
  часа: "hour",
  часу: "hour",
  часиков: "hour",
  часика: "hour",
  часике: "hour",
  часик: "hour",
  день: "day",
  дня: "day",
  дней: "day",
  суток: "day",
  сутки: "day",
  неделя: "week",
  неделе: "week",
  недели: "week",
  неделю: "week",
  недель: "week",
  недельке: "week",
  недельки: "week",
  неделек: "week",
  месяц: "month",
  месяце: "month",
  месяцев: "month",
  месяца: "month",
  квартал: "quarter",
  квартале: "quarter",
  кварталов: "quarter",
  год: "year",
  года: "year",
  году: "year",
  годов: "year",
  лет: "year",
  годик: "year",
  годика: "year",
  годиков: "year"
};
var NUMBER_PATTERN5 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY5)}|[0-9]+|[0-9]+\\.[0-9]+|пол|несколько|пар(?:ы|у)|\\s{0,3})`;
function parseNumberPattern5(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY5[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY5[num];
  }
  if (num.match(/несколько/)) {
    return 3;
  } else if (num.match(/пол/)) {
    return 0.5;
  } else if (num.match(/пар/)) {
    return 2;
  } else if (num === "") {
    return 1;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN4 = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY3)}|[0-9]{1,2}(?:го|ого|е|ое)?)`;
function parseOrdinalNumberPattern4(match) {
  const num = match.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY3[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY3[num];
  }
  return parseInt(num);
}
var year = "(?:\\s+(?:году|года|год|г|г.))?";
var YEAR_PATTERN6 = `(?:[1-9][0-9]{0,3}${year}\\s*(?:н.э.|до н.э.|н. э.|до н. э.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;
function parseYear6(match) {
  if (/(год|года|г|г.)/i.test(match)) {
    match = match.replace(/(год|года|г|г.)/i, "");
  }
  if (/(до н.э.|до н. э.)/i.test(match)) {
    match = match.replace(/(до н.э.|до н. э.)/i, "");
    return -parseInt(match);
  }
  if (/(н. э.|н.э.)/i.test(match)) {
    match = match.replace(/(н. э.|н.э.)/i, "");
    return parseInt(match);
  }
  const rawYearNumber = parseInt(match);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN5 = `(${NUMBER_PATTERN5})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY5)})`;
var SINGLE_TIME_UNIT_REGEX5 = new RegExp(SINGLE_TIME_UNIT_PATTERN5, "i");
var TIME_UNITS_PATTERN5 = repeatedTimeunitPattern(`(?:(?:около|примерно)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN5);
function parseDuration5(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX5.exec(remainingText);
  while (match) {
    collectDateTimeFragment5(fragments, match);
    remainingText = remainingText.substring(match[0].length).trim();
    match = SINGLE_TIME_UNIT_REGEX5.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment5(fragments, match) {
  const num = parseNumberPattern5(match[1]);
  const unit = TIME_UNIT_DICTIONARY5[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUTimeUnitWithinFormatParser.js
var PATTERN42 = `(?:(?:около|примерно)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN5})${REGEX_PARTS.rightBoundary}`;
var RUTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  patternLeftBoundary() {
    return REGEX_PARTS.leftBoundary;
  }
  innerPattern(context) {
    return context.option.forwardDate ? new RegExp(PATTERN42, REGEX_PARTS.flags) : new RegExp(`(?:в течение|в течении)\\s*${PATTERN42}`, REGEX_PARTS.flags);
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration5(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/AbstractParserWithWordBoundaryChecking.js
var AbstractParserWithLeftBoundaryChecking = class extends AbstractParserWithWordBoundaryChecking {
  patternLeftBoundary() {
    return REGEX_PARTS.leftBoundary;
  }
  innerPattern(context) {
    return new RegExp(this.innerPatternString(context), REGEX_PARTS.flags);
  }
  innerPatternHasChange(context, currentInnerPattern) {
    return false;
  }
};
var AbstractParserWithLeftRightBoundaryChecking = class extends AbstractParserWithLeftBoundaryChecking {
  innerPattern(context) {
    return new RegExp(`${this.innerPatternString(context)}${REGEX_PARTS.rightBoundary}`, REGEX_PARTS.flags);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUMonthNameLittleEndianParser.js
var DATE_GROUP9 = 1;
var DATE_TO_GROUP7 = 2;
var MONTH_NAME_GROUP11 = 3;
var YEAR_GROUP16 = 4;
var RUMonthNameLittleEndianParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(?:с)?\\s*(${ORDINAL_NUMBER_PATTERN4})(?:\\s{0,3}(?:по|-|–|до)?\\s{0,3}(${ORDINAL_NUMBER_PATTERN4}))?(?:-|\\/|\\s{0,3}(?:of)?\\s{0,3})(${matchAnyPattern(MONTH_DICTIONARY6)})(?:(?:-|\\/|,?\\s{0,3})(${YEAR_PATTERN6}(?![^\\s]\\d)))?`;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY6[match[MONTH_NAME_GROUP11].toLowerCase()];
    const day = parseOrdinalNumberPattern4(match[DATE_GROUP9]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP9].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP16]) {
      const yearNumber = parseYear6(match[YEAR_GROUP16]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP7]) {
      const endDate = parseOrdinalNumberPattern4(match[DATE_TO_GROUP7]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUMonthNameParser.js
var MONTH_NAME_GROUP12 = 2;
var YEAR_GROUP17 = 3;
var RUMonthNameParser = class extends AbstractParserWithLeftBoundaryChecking {
  innerPatternString(context) {
    return `((?:в)\\s*)?(${matchAnyPattern(MONTH_DICTIONARY6)})\\s*(?:[,-]?\\s*(${YEAR_PATTERN6})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`;
  }
  innerExtract(context, match) {
    const monthName = match[MONTH_NAME_GROUP12].toLowerCase();
    if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY2[monthName]) {
      return null;
    }
    const result = context.createParsingResult(match.index, match.index + match[0].length);
    result.start.imply("day", 1);
    const month = MONTH_DICTIONARY6[monthName];
    result.start.assign("month", month);
    if (match[YEAR_GROUP17]) {
      const year3 = parseYear6(match[YEAR_GROUP17]);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, 1, month);
      result.start.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUTimeExpressionParser.js
var RUTimeExpressionParser = class extends AbstractTimeExpressionParser {
  constructor(strictMode) {
    super(strictMode);
  }
  patternFlags() {
    return REGEX_PARTS.flags;
  }
  primaryPatternLeftBoundary() {
    return `(^|\\s|T|(?:[^\\p{L}\\p{N}_]))`;
  }
  followingPhase() {
    return `\\s*(?:\\-|\\–|\\~|\\〜|до|и|по|\\?)\\s*`;
  }
  primaryPrefix() {
    return `(?:(?:в|с)\\s*)??`;
  }
  primarySuffix() {
    return `(?:\\s*(?:утра|вечера|после полудня))?(?!\\/)${REGEX_PARTS.rightBoundary}`;
  }
  extractPrimaryTimeComponents(context, match) {
    const components = super.extractPrimaryTimeComponents(context, match);
    if (components) {
      if (match[0].endsWith("вечера")) {
        const hour = components.get("hour");
        if (hour >= 6 && hour < 12) {
          components.assign("hour", components.get("hour") + 12);
          components.assign("meridiem", Meridiem.PM);
        } else if (hour < 6) {
          components.assign("meridiem", Meridiem.AM);
        }
      }
      if (match[0].endsWith("после полудня")) {
        components.assign("meridiem", Meridiem.PM);
        const hour = components.get("hour");
        if (hour >= 0 && hour <= 6) {
          components.assign("hour", components.get("hour") + 12);
        }
      }
      if (match[0].endsWith("утра")) {
        components.assign("meridiem", Meridiem.AM);
        const hour = components.get("hour");
        if (hour < 12) {
          components.assign("hour", components.get("hour"));
        }
      }
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUTimeUnitAgoFormatParser.js
var RUTimeUnitAgoFormatParser = class extends AbstractParserWithLeftBoundaryChecking {
  innerPatternString(context) {
    return `(${TIME_UNITS_PATTERN5})\\s{0,5}назад(?=(?:\\W|$))`;
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration5(match[1]);
    const outputTimeUnits = reverseDuration(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/refiners/RUMergeDateRangeRefiner.js
var RUMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(и до|и по|до|по|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/refiners/RUMergeDateTimeRefiner.js
var RUMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp(`^\\s*(T|в|,|-)?\\s*$`);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUCasualDateParser.js
var RUCasualDateParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(?:с|со)?\\s*(сегодня|вчера|завтра|послезавтра|послепослезавтра|позапозавчера|позавчера)`;
  }
  innerExtract(context, match) {
    const lowerText = match[1].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "сегодня":
        return today(context.reference);
      case "вчера":
        return yesterday(context.reference);
      case "завтра":
        return tomorrow(context.reference);
      case "послезавтра":
        return theDayAfter(context.reference, 2);
      case "послепослезавтра":
        return theDayAfter(context.reference, 3);
      case "позавчера":
        return theDayBefore(context.reference, 2);
      case "позапозавчера":
        return theDayBefore(context.reference, 3);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUCasualTimeParser.js
var RUCasualTimeParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(сейчас|прошлым\\s*вечером|прошлой\\s*ночью|следующей\\s*ночью|сегодня\\s*ночью|этой\\s*ночью|ночью|этим утром|утром|утра|в\\s*полдень|вечером|вечера|в\\s*полночь)`;
  }
  innerExtract(context, match) {
    let targetDate = context.refDate;
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    if (lowerText === "сейчас") {
      return now(context.reference);
    }
    if (lowerText === "вечером" || lowerText === "вечера") {
      return evening(context.reference);
    }
    if (lowerText.endsWith("утром") || lowerText.endsWith("утра")) {
      return morning(context.reference);
    }
    if (lowerText.match(/в\s*полдень/)) {
      return noon(context.reference);
    }
    if (lowerText.match(/прошлой\s*ночью/)) {
      return lastNight(context.reference);
    }
    if (lowerText.match(/прошлым\s*вечером/)) {
      return yesterdayEvening(context.reference);
    }
    if (lowerText.match(/следующей\s*ночью/)) {
      const daysToAdd = targetDate.getHours() < 22 ? 1 : 2;
      const nextDay = new Date(targetDate.getTime());
      nextDay.setDate(nextDay.getDate() + daysToAdd);
      assignSimilarDate(component, nextDay);
      component.imply("hour", 0);
    }
    if (lowerText.match(/в\s*полночь/) || lowerText.endsWith("ночью")) {
      return midnight(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUWeekdayParser.js
var PREFIX_GROUP6 = 1;
var WEEKDAY_GROUP6 = 2;
var POSTFIX_GROUP5 = 3;
var RUWeekdayParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(?:(?:,|\\(|（)\\s*)?(?:в\\s*?)?(?:(эту|этот|прошлый|прошлую|следующий|следующую|следующего)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY6)})(?:\\s*(?:,|\\)|）))?(?:\\s*на\\s*(этой|прошлой|следующей)\\s*неделе)?`;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP6].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY6[dayOfWeek];
    const prefix = match[PREFIX_GROUP6];
    const postfix = match[POSTFIX_GROUP5];
    let modifierWord = prefix || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord == "прошлый" || modifierWord == "прошлую" || modifierWord == "прошлой") {
      modifier = "last";
    } else if (modifierWord == "следующий" || modifierWord == "следующую" || modifierWord == "следующей" || modifierWord == "следующего") {
      modifier = "next";
    } else if (modifierWord == "этот" || modifierWord == "эту" || modifierWord == "этой") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RURelativeDateFormatParser.js
var MODIFIER_WORD_GROUP3 = 1;
var RELATIVE_WORD_GROUP3 = 2;
var RURelativeDateFormatParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(в прошлом|на прошлой|на следующей|в следующем|на этой|в этом)\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY5)})`;
  }
  innerExtract(context, match) {
    const modifier = match[MODIFIER_WORD_GROUP3].toLowerCase();
    const unitWord = match[RELATIVE_WORD_GROUP3].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY5[unitWord];
    if (modifier == "на следующей" || modifier == "в следующем") {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "в прошлом" || modifier == "на прошлой") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = new Date(context.reference.instant.getTime());
    if (timeunit.match(/week/i)) {
      date.setDate(date.getDate() - date.getDay());
      components.imply("day", date.getDate());
      components.imply("month", date.getMonth() + 1);
      components.imply("year", date.getFullYear());
    } else if (timeunit.match(/month/i)) {
      date.setDate(1);
      components.imply("day", date.getDate());
      components.assign("year", date.getFullYear());
      components.assign("month", date.getMonth() + 1);
    } else if (timeunit.match(/year/i)) {
      date.setDate(1);
      date.setMonth(0);
      components.imply("day", date.getDate());
      components.imply("month", date.getMonth() + 1);
      components.assign("year", date.getFullYear());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js
var RUTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(эти|последние|прошлые|следующие|после|спустя|через|\\+|-)\\s*(${TIME_UNITS_PATTERN5})`;
  }
  innerExtract(context, match) {
    const prefix = match[1].toLowerCase();
    let timeUnits = parseDuration5(match[2]);
    switch (prefix) {
      case "последние":
      case "прошлые":
      case "-":
        timeUnits = reverseDuration(timeUnits);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/index.js
var casual10 = new Chrono(createCasualConfiguration9());
var strict10 = new Chrono(createConfiguration9(true));
function parse10(text, ref, option) {
  return casual10.parse(text, ref, option);
}
function parseDate10(text, ref, option) {
  return casual10.parseDate(text, ref, option);
}
function createCasualConfiguration9() {
  const option = createConfiguration9(false);
  option.parsers.unshift(new RUCasualDateParser());
  option.parsers.unshift(new RUCasualTimeParser());
  option.parsers.unshift(new RUMonthNameParser());
  option.parsers.unshift(new RURelativeDateFormatParser());
  option.parsers.unshift(new RUTimeUnitCasualRelativeFormatParser());
  return option;
}
function createConfiguration9(strictMode = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(true),
      new RUTimeUnitWithinFormatParser(),
      new RUMonthNameLittleEndianParser(),
      new RUWeekdayParser(),
      new RUTimeExpressionParser(strictMode),
      new RUTimeUnitAgoFormatParser()
    ],
    refiners: [new RUMergeDateTimeRefiner(), new RUMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/es/index.js
var es_exports = {};
__export(es_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual11,
  createCasualConfiguration: () => createCasualConfiguration10,
  createConfiguration: () => createConfiguration10,
  parse: () => parse11,
  parseDate: () => parseDate11,
  strict: () => strict11
});

// node_modules/chrono-node/dist/esm/locales/es/constants.js
var WEEKDAY_DICTIONARY7 = {
  "domingo": 0,
  "dom": 0,
  "lunes": 1,
  "lun": 1,
  "martes": 2,
  "mar": 2,
  "miércoles": 3,
  "miercoles": 3,
  "mié": 3,
  "mie": 3,
  "jueves": 4,
  "jue": 4,
  "viernes": 5,
  "vie": 5,
  "sábado": 6,
  "sabado": 6,
  "sáb": 6,
  "sab": 6
};
var MONTH_DICTIONARY7 = {
  "enero": 1,
  "ene": 1,
  "ene.": 1,
  "febrero": 2,
  "feb": 2,
  "feb.": 2,
  "marzo": 3,
  "mar": 3,
  "mar.": 3,
  "abril": 4,
  "abr": 4,
  "abr.": 4,
  "mayo": 5,
  "may": 5,
  "may.": 5,
  "junio": 6,
  "jun": 6,
  "jun.": 6,
  "julio": 7,
  "jul": 7,
  "jul.": 7,
  "agosto": 8,
  "ago": 8,
  "ago.": 8,
  "septiembre": 9,
  "setiembre": 9,
  "sep": 9,
  "sep.": 9,
  "octubre": 10,
  "oct": 10,
  "oct.": 10,
  "noviembre": 11,
  "nov": 11,
  "nov.": 11,
  "diciembre": 12,
  "dic": 12,
  "dic.": 12
};
var INTEGER_WORD_DICTIONARY6 = {
  "uno": 1,
  "dos": 2,
  "tres": 3,
  "cuatro": 4,
  "cinco": 5,
  "seis": 6,
  "siete": 7,
  "ocho": 8,
  "nueve": 9,
  "diez": 10,
  "once": 11,
  "doce": 12,
  "trece": 13
};
var TIME_UNIT_DICTIONARY6 = {
  "sec": "second",
  "segundo": "second",
  "segundos": "second",
  "min": "minute",
  "mins": "minute",
  "minuto": "minute",
  "minutos": "minute",
  "h": "hour",
  "hr": "hour",
  "hrs": "hour",
  "hora": "hour",
  "horas": "hour",
  "día": "day",
  "días": "day",
  "semana": "week",
  "semanas": "week",
  "mes": "month",
  "meses": "month",
  "cuarto": "quarter",
  "cuartos": "quarter",
  "año": "year",
  "años": "year"
};
var NUMBER_PATTERN6 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY6)}|[0-9]+|[0-9]+\\.[0-9]+|un?|uno?|una?|algunos?|unos?|demi-?)`;
function parseNumberPattern6(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY6[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY6[num];
  } else if (num === "un" || num === "una" || num === "uno") {
    return 1;
  } else if (num.match(/algunos?/)) {
    return 3;
  } else if (num.match(/unos?/)) {
    return 3;
  } else if (num.match(/media?/)) {
    return 0.5;
  }
  return parseFloat(num);
}
var YEAR_PATTERN7 = "[0-9]{1,4}(?![^\\s]\\d)(?:\\s*[a|d]\\.?\\s*c\\.?|\\s*a\\.?\\s*d\\.?)?";
function parseYear7(match) {
  if (match.match(/^[0-9]{1,4}$/)) {
    let yearNumber = parseInt(match);
    if (yearNumber < 100) {
      if (yearNumber > 50) {
        yearNumber = yearNumber + 1900;
      } else {
        yearNumber = yearNumber + 2e3;
      }
    }
    return yearNumber;
  }
  if (match.match(/a\.?\s*c\.?/i)) {
    match = match.replace(/a\.?\s*c\.?/i, "");
    return -parseInt(match);
  }
  return parseInt(match);
}
var SINGLE_TIME_UNIT_PATTERN6 = `(${NUMBER_PATTERN6})\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY6)})\\s{0,5}`;
var SINGLE_TIME_UNIT_REGEX6 = new RegExp(SINGLE_TIME_UNIT_PATTERN6, "i");
var TIME_UNITS_PATTERN6 = repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN6);
function parseDuration6(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX6.exec(remainingText);
  while (match) {
    collectDateTimeFragment6(fragments, match);
    remainingText = remainingText.substring(match[0].length);
    match = SINGLE_TIME_UNIT_REGEX6.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment6(fragments, match) {
  const num = parseNumberPattern6(match[1]);
  const unit = TIME_UNIT_DICTIONARY6[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/es/parsers/ESWeekdayParser.js
var PATTERN43 = new RegExp(`(?:(?:\\,|\\(|\\（)\\s*)?(?:(este|esta|pasado|pr[oó]ximo)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY7)})(?:\\s*(?:\\,|\\)|\\）))?(?:\\s*(este|esta|pasado|pr[óo]ximo)\\s*semana)?(?=\\W|\\d|$)`, "i");
var PREFIX_GROUP7 = 1;
var WEEKDAY_GROUP7 = 2;
var POSTFIX_GROUP6 = 3;
var ESWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN43;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP7].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY7[dayOfWeek];
    if (weekday === void 0) {
      return null;
    }
    const prefix = match[PREFIX_GROUP7];
    const postfix = match[POSTFIX_GROUP6];
    let norm = prefix || postfix || "";
    norm = norm.toLowerCase();
    let modifier = null;
    if (norm == "pasado") {
      modifier = "this";
    } else if (norm == "próximo" || norm == "proximo") {
      modifier = "next";
    } else if (norm == "este") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/es/parsers/ESTimeExpressionParser.js
var ESTimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:aslas|deslas|las?|al?|de|del)\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\–|\\~|\\〜|a(?:l)?|\\?)\\s*";
  }
};

// node_modules/chrono-node/dist/esm/locales/es/refiners/ESMergeDateTimeRefiner.js
var ESMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(?:,|de|aslas|a)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/es/refiners/ESMergeDateRangeRefiner.js
var ESMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(?:-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/es/parsers/ESMonthNameLittleEndianParser.js
var PATTERN44 = new RegExp(`([0-9]{1,2})(?:º|ª|°)?(?:\\s*(?:desde|de|\\-|\\–|ao?|\\s)\\s*([0-9]{1,2})(?:º|ª|°)?)?\\s*(?:de)?\\s*(?:-|/|\\s*(?:de|,)?\\s*)(${matchAnyPattern(MONTH_DICTIONARY7)})(?:\\s*(?:de|,)?\\s*(${YEAR_PATTERN7}))?(?=\\W|$)`, "i");
var DATE_GROUP10 = 1;
var DATE_TO_GROUP8 = 2;
var MONTH_NAME_GROUP13 = 3;
var YEAR_GROUP18 = 4;
var ESMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN44;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY7[match[MONTH_NAME_GROUP13].toLowerCase()];
    const day = parseInt(match[DATE_GROUP10]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP10].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP18]) {
      const yearNumber = parseYear7(match[YEAR_GROUP18]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP8]) {
      const endDate = parseInt(match[DATE_TO_GROUP8]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/es/parsers/ESCasualDateParser.js
var ESCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(ahora|hoy|mañana|ayer)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "ahora":
        return now(context.reference);
      case "hoy":
        return today(context.reference);
      case "mañana":
        return tomorrow(context.reference);
      case "ayer":
        return yesterday(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/es/parsers/ESCasualTimeParser.js
var ESCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return /(?:esta\s*)?(mañana|tarde|medianoche|mediodia|mediodía|noche)(?=\W|$)/i;
  }
  innerExtract(context, match) {
    const targetDate = context.refDate;
    const component = context.createParsingComponents();
    switch (match[1].toLowerCase()) {
      case "tarde":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 15);
        break;
      case "noche":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 22);
        break;
      case "mañana":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 6);
        break;
      case "medianoche":
        const nextDay = new Date(targetDate.getTime());
        nextDay.setDate(nextDay.getDate() + 1);
        assignSimilarDate(component, nextDay);
        implySimilarTime(component, nextDay);
        component.imply("hour", 0);
        component.imply("minute", 0);
        component.imply("second", 0);
        break;
      case "mediodia":
      case "mediodía":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 12);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/es/parsers/ESTimeUnitWithinFormatParser.js
var ESTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp(`(?:en|por|durante|de|dentro de)\\s*(${TIME_UNITS_PATTERN6})(?=\\W|$)`, "i");
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration6(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/es/index.js
var casual11 = new Chrono(createCasualConfiguration10());
var strict11 = new Chrono(createConfiguration10(true));
function parse11(text, ref, option) {
  return casual11.parse(text, ref, option);
}
function parseDate11(text, ref, option) {
  return casual11.parseDate(text, ref, option);
}
function createCasualConfiguration10(littleEndian = true) {
  const option = createConfiguration10(false, littleEndian);
  option.parsers.push(new ESCasualDateParser());
  option.parsers.push(new ESCasualTimeParser());
  return option;
}
function createConfiguration10(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(littleEndian),
      new ESWeekdayParser(),
      new ESTimeExpressionParser(),
      new ESMonthNameLittleEndianParser(),
      new ESTimeUnitWithinFormatParser()
    ],
    refiners: [new ESMergeDateTimeRefiner(), new ESMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/uk/index.js
var uk_exports = {};
__export(uk_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual12,
  createCasualConfiguration: () => createCasualConfiguration11,
  createConfiguration: () => createConfiguration11,
  parse: () => parse12,
  parseDate: () => parseDate12,
  strict: () => strict12
});

// node_modules/chrono-node/dist/esm/locales/uk/constants.js
var REGEX_PARTS2 = {
  leftBoundary: "([^\\p{L}\\p{N}_]|^)",
  rightBoundary: "(?=[^\\p{L}\\p{N}_]|$)",
  flags: "iu"
};
var WEEKDAY_DICTIONARY8 = {
  "неділя": 0,
  "неділі": 0,
  "неділю": 0,
  "нд": 0,
  "нд.": 0,
  "понеділок": 1,
  "понеділка": 1,
  "пн": 1,
  "пн.": 1,
  "вівторок": 2,
  "вівторка": 2,
  "вт": 2,
  "вт.": 2,
  "середа": 3,
  "середи": 3,
  "середу": 3,
  "ср": 3,
  "ср.": 3,
  "четвер": 4,
  "четверга": 4,
  "четвергу": 4,
  "чт": 4,
  "чт.": 4,
  "п'ятниця": 5,
  "п'ятниці": 5,
  "п'ятницю": 5,
  "пт": 5,
  "пт.": 5,
  "субота": 6,
  "суботи": 6,
  "суботу": 6,
  "сб": 6,
  "сб.": 6
};
var FULL_MONTH_NAME_DICTIONARY3 = {
  "січень": 1,
  "січня": 1,
  "січні": 1,
  "лютий": 2,
  "лютого": 2,
  "лютому": 2,
  "березень": 3,
  "березня": 3,
  "березні": 3,
  "квітень": 4,
  "квітня": 4,
  "квітні": 4,
  "травень": 5,
  "травня": 5,
  "травні": 5,
  "червень": 6,
  "червня": 6,
  "червні": 6,
  "липень": 7,
  "липня": 7,
  "липні": 7,
  "серпень": 8,
  "серпня": 8,
  "серпні": 8,
  "вересень": 9,
  "вересня": 9,
  "вересні": 9,
  "жовтень": 10,
  "жовтня": 10,
  "жовтні": 10,
  "листопад": 11,
  "листопада": 11,
  "листопаду": 11,
  "грудень": 12,
  "грудня": 12,
  "грудні": 12
};
var MONTH_DICTIONARY8 = {
  ...FULL_MONTH_NAME_DICTIONARY3,
  "січ": 1,
  "січ.": 1,
  "лют": 2,
  "лют.": 2,
  "бер": 3,
  "бер.": 3,
  "квіт": 4,
  "квіт.": 4,
  "трав": 5,
  "трав.": 5,
  "черв": 6,
  "черв.": 6,
  "лип": 7,
  "лип.": 7,
  "серп": 8,
  "серп.": 8,
  "сер": 8,
  "cер.": 8,
  "вер": 9,
  "вер.": 9,
  "верес": 9,
  "верес.": 9,
  "жовт": 10,
  "жовт.": 10,
  "листоп": 11,
  "листоп.": 11,
  "груд": 12,
  "груд.": 12
};
var INTEGER_WORD_DICTIONARY7 = {
  "один": 1,
  "одна": 1,
  "одної": 1,
  "одну": 1,
  "дві": 2,
  "два": 2,
  "двох": 2,
  "три": 3,
  "трьох": 3,
  "чотири": 4,
  "чотирьох": 4,
  "п'ять": 5,
  "п'яти": 5,
  "шість": 6,
  "шести": 6,
  "сім": 7,
  "семи": 7,
  "вісім": 8,
  "восьми": 8,
  "дев'ять": 9,
  "дев'яти": 9,
  "десять": 10,
  "десяти": 10,
  "одинадцять": 11,
  "одинадцяти": 11,
  "дванадцять": 12,
  "дванадцяти": 12
};
var ORDINAL_WORD_DICTIONARY4 = {
  "перше": 1,
  "першого": 1,
  "друге": 2,
  "другого": 2,
  "третє": 3,
  "третього": 3,
  "четверте": 4,
  "четвертого": 4,
  "п'яте": 5,
  "п'ятого": 5,
  "шосте": 6,
  "шостого": 6,
  "сьоме": 7,
  "сьомого": 7,
  "восьме": 8,
  "восьмого": 8,
  "дев'яте": 9,
  "дев'ятого": 9,
  "десяте": 10,
  "десятого": 10,
  "одинадцяте": 11,
  "одинадцятого": 11,
  "дванадцяте": 12,
  "дванадцятого": 12,
  "тринадцяте": 13,
  "тринадцятого": 13,
  "чотирнадцяте": 14,
  "чотинрнадцятого": 14,
  "п'ятнадцяте": 15,
  "п'ятнадцятого": 15,
  "шістнадцяте": 16,
  "шістнадцятого": 16,
  "сімнадцяте": 17,
  "сімнадцятого": 17,
  "вісімнадцяте": 18,
  "вісімнадцятого": 18,
  "дев'ятнадцяте": 19,
  "дев'ятнадцятого": 19,
  "двадцяте": 20,
  "двадцятого": 20,
  "двадцять перше": 21,
  "двадцять першого": 21,
  "двадцять друге": 22,
  "двадцять другого": 22,
  "двадцять третє": 23,
  "двадцять третього": 23,
  "двадцять четверте": 24,
  "двадцять четвертого": 24,
  "двадцять п'яте": 25,
  "двадцять п'ятого": 25,
  "двадцять шосте": 26,
  "двадцять шостого": 26,
  "двадцять сьоме": 27,
  "двадцять сьомого": 27,
  "двадцять восьме": 28,
  "двадцять восьмого": 28,
  "двадцять дев'яте": 29,
  "двадцять дев'ятого": 29,
  "тридцяте": 30,
  "тридцятого": 30,
  "тридцять перше": 31,
  "тридцять першого": 31
};
var TIME_UNIT_DICTIONARY7 = {
  сек: "second",
  секунда: "second",
  секунд: "second",
  секунди: "second",
  секунду: "second",
  секундочок: "second",
  секундочки: "second",
  секундочку: "second",
  хв: "minute",
  хвилина: "minute",
  хвилин: "minute",
  хвилини: "minute",
  хвилину: "minute",
  хвилинок: "minute",
  хвилинки: "minute",
  хвилинку: "minute",
  хвилиночок: "minute",
  хвилиночки: "minute",
  хвилиночку: "minute",
  год: "hour",
  година: "hour",
  годин: "hour",
  години: "hour",
  годину: "hour",
  годинка: "hour",
  годинок: "hour",
  годинки: "hour",
  годинку: "hour",
  день: "day",
  дня: "day",
  днів: "day",
  дні: "day",
  доба: "day",
  добу: "day",
  тиждень: "week",
  тижню: "week",
  тижня: "week",
  тижні: "week",
  тижнів: "week",
  місяць: "month",
  місяців: "month",
  місяці: "month",
  місяця: "month",
  квартал: "quarter",
  кварталу: "quarter",
  квартала: "quarter",
  кварталів: "quarter",
  кварталі: "quarter",
  рік: "year",
  року: "year",
  році: "year",
  років: "year",
  роки: "year"
};
var NUMBER_PATTERN7 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY7)}|[0-9]+|[0-9]+\\.[0-9]+|пів|декілька|пар(?:у)|\\s{0,3})`;
function parseNumberPattern7(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY7[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY7[num];
  }
  if (num.match(/декілька/)) {
    return 2;
  } else if (num.match(/пів/)) {
    return 0.5;
  } else if (num.match(/пар/)) {
    return 2;
  } else if (num === "") {
    return 1;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN5 = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY4)}|[0-9]{1,2}(?:го|ого|е)?)`;
function parseOrdinalNumberPattern5(match) {
  const num = match.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY4[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY4[num];
  }
  return parseInt(num);
}
var year2 = "(?:\\s+(?:року|рік|р|р.))?";
var YEAR_PATTERN8 = `(?:[1-9][0-9]{0,3}${year2}\\s*(?:н.е.|до н.е.|н. е.|до н. е.)|[1-2][0-9]{3}${year2}|[5-9][0-9]${year2})`;
function parseYearPattern(match) {
  if (/(рік|року|р|р.)/i.test(match)) {
    match = match.replace(/(рік|року|р|р.)/i, "");
  }
  if (/(до н.е.|до н. е.)/i.test(match)) {
    match = match.replace(/(до н.е.|до н. е.)/i, "");
    return -parseInt(match);
  }
  if (/(н. е.|н.е.)/i.test(match)) {
    match = match.replace(/(н. е.|н.е.)/i, "");
    return parseInt(match);
  }
  const rawYearNumber = parseInt(match);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN7 = `(${NUMBER_PATTERN7})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY7)})`;
var SINGLE_TIME_UNIT_REGEX7 = new RegExp(SINGLE_TIME_UNIT_PATTERN7, "i");
var TIME_UNITS_PATTERN7 = repeatedTimeunitPattern(`(?:(?:близько|приблизно)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN7);
function parseDuration7(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX7.exec(remainingText);
  while (match) {
    collectDateTimeFragment7(fragments, match);
    remainingText = remainingText.substring(match[0].length).trim();
    match = SINGLE_TIME_UNIT_REGEX7.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment7(fragments, match) {
  const num = parseNumberPattern7(match[1]);
  const unit = TIME_UNIT_DICTIONARY7[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKTimeUnitWithinFormatParser.js
var PATTERN45 = `(?:(?:приблизно|орієнтовно)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN7})${REGEX_PARTS2.rightBoundary}`;
var UKTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  patternLeftBoundary() {
    return REGEX_PARTS2.leftBoundary;
  }
  innerPattern(context) {
    return context.option.forwardDate ? new RegExp(PATTERN45, "i") : new RegExp(`(?:протягом|на протязі|протягом|упродовж|впродовж)\\s*${PATTERN45}`, REGEX_PARTS2.flags);
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration7(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/AbstractParserWithWordBoundaryChecking.js
var AbstractParserWithLeftBoundaryChecking2 = class extends AbstractParserWithWordBoundaryChecking {
  patternLeftBoundary() {
    return REGEX_PARTS2.leftBoundary;
  }
  innerPattern(context) {
    return new RegExp(this.innerPatternString(context), REGEX_PARTS2.flags);
  }
  innerPatternHasChange(context, currentInnerPattern) {
    return false;
  }
};
var AbstractParserWithLeftRightBoundaryChecking2 = class extends AbstractParserWithLeftBoundaryChecking2 {
  innerPattern(context) {
    return new RegExp(`${this.innerPatternString(context)}${REGEX_PARTS2.rightBoundary}`, REGEX_PARTS2.flags);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKMonthNameLittleEndianParser.js
var DATE_GROUP11 = 1;
var DATE_TO_GROUP9 = 2;
var MONTH_NAME_GROUP14 = 3;
var YEAR_GROUP19 = 4;
var UKMonthNameLittleEndianParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(?:з|із)?\\s*(${ORDINAL_NUMBER_PATTERN5})(?:\\s{0,3}(?:по|-|–|до)?\\s{0,3}(${ORDINAL_NUMBER_PATTERN5}))?(?:-|\\/|\\s{0,3}(?:of)?\\s{0,3})(${matchAnyPattern(MONTH_DICTIONARY8)})(?:(?:-|\\/|,?\\s{0,3})(${YEAR_PATTERN8}(?![^\\s]\\d)))?`;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY8[match[MONTH_NAME_GROUP14].toLowerCase()];
    const day = parseOrdinalNumberPattern5(match[DATE_GROUP11]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP11].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP19]) {
      const yearNumber = parseYearPattern(match[YEAR_GROUP19]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.reference.instant, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP9]) {
      const endDate = parseOrdinalNumberPattern5(match[DATE_TO_GROUP9]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKMonthNameParser.js
var MONTH_NAME_GROUP15 = 2;
var YEAR_GROUP20 = 3;
var UkMonthNameParser = class extends AbstractParserWithLeftBoundaryChecking2 {
  innerPatternString(context) {
    return `((?:в|у)\\s*)?(${matchAnyPattern(MONTH_DICTIONARY8)})\\s*(?:[,-]?\\s*(${YEAR_PATTERN8})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`;
  }
  innerExtract(context, match) {
    const monthName = match[MONTH_NAME_GROUP15].toLowerCase();
    if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY3[monthName]) {
      return null;
    }
    const result = context.createParsingResult(match.index, match.index + match[0].length);
    result.start.imply("day", 1);
    const month = MONTH_DICTIONARY8[monthName];
    result.start.assign("month", month);
    if (match[YEAR_GROUP20]) {
      const year3 = parseYearPattern(match[YEAR_GROUP20]);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.reference.instant, 1, month);
      result.start.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKTimeExpressionParser.js
var UKTimeExpressionParser = class extends AbstractTimeExpressionParser {
  constructor(strictMode) {
    super(strictMode);
  }
  patternFlags() {
    return REGEX_PARTS2.flags;
  }
  primaryPatternLeftBoundary() {
    return `(^|\\s|T|(?:[^\\p{L}\\p{N}_]))`;
  }
  followingPhase() {
    return `\\s*(?:\\-|\\–|\\~|\\〜|до|і|по|\\?)\\s*`;
  }
  primaryPrefix() {
    return `(?:(?:в|у|о|об|з|із|від)\\s*)??`;
  }
  primarySuffix() {
    return `(?:\\s*(?:ранку|вечора|по обіді|після обіду))?(?!\\/)${REGEX_PARTS2.rightBoundary}`;
  }
  extractPrimaryTimeComponents(context, match) {
    const components = super.extractPrimaryTimeComponents(context, match);
    if (components) {
      if (match[0].endsWith("вечора")) {
        const hour = components.get("hour");
        if (hour >= 6 && hour < 12) {
          components.assign("hour", components.get("hour") + 12);
          components.assign("meridiem", Meridiem.PM);
        } else if (hour < 6) {
          components.assign("meridiem", Meridiem.AM);
        }
      }
      if (match[0].endsWith("по обіді") || match[0].endsWith("після обіду")) {
        components.assign("meridiem", Meridiem.PM);
        const hour = components.get("hour");
        if (hour >= 0 && hour <= 6) {
          components.assign("hour", components.get("hour") + 12);
        }
      }
      if (match[0].endsWith("ранку")) {
        components.assign("meridiem", Meridiem.AM);
        const hour = components.get("hour");
        if (hour < 12) {
          components.assign("hour", components.get("hour"));
        }
      }
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKTimeUnitAgoFormatParser.js
var UKTimeUnitAgoFormatParser = class extends AbstractParserWithLeftBoundaryChecking2 {
  innerPatternString(context) {
    return `(${TIME_UNITS_PATTERN7})\\s{0,5}тому(?=(?:\\W|$))`;
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration7(match[1]);
    const outputTimeUnits = reverseDuration(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/refiners/UKMergeDateRangeRefiner.js
var UKMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(і до|і по|до|по|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/refiners/UKMergeDateTimeRefiner.js
var UKMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp(`^\\s*(T|в|у|о|,|-)?\\s*$`);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKCasualDateParser.js
var UKCasualDateParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(?:з|із|від)?\\s*(сьогодні|вчора|завтра|післязавтра|післяпіслязавтра|позапозавчора|позавчора)`;
  }
  innerExtract(context, match) {
    const lowerText = match[1].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "сьогодні":
        return today(context.reference);
      case "вчора":
        return yesterday(context.reference);
      case "завтра":
        return tomorrow(context.reference);
      case "післязавтра":
        return theDayAfter(context.reference, 2);
      case "післяпіслязавтра":
        return theDayAfter(context.reference, 3);
      case "позавчора":
        return theDayBefore(context.reference, 2);
      case "позапозавчора":
        return theDayBefore(context.reference, 3);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKCasualTimeParser.js
var UKCasualTimeParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(зараз|минулого\\s*вечора|минулої\\s*ночі|наступної\\s*ночі|сьогодні\\s*вночі|цієї\\s*ночі|цього ранку|вранці|ранку|зранку|опівдні|ввечері|вечора|опівночі|вночі)`;
  }
  innerExtract(context, match) {
    let targetDate = context.refDate;
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    if (lowerText === "зараз") {
      return now(context.reference);
    }
    if (lowerText === "ввечері" || lowerText === "вечора") {
      return evening(context.reference);
    }
    if (lowerText.endsWith("вранці") || lowerText.endsWith("ранку") || lowerText.endsWith("зранку")) {
      return morning(context.reference);
    }
    if (lowerText.endsWith("опівдні")) {
      return noon(context.reference);
    }
    if (lowerText.match(/минулої\s*ночі/)) {
      return lastNight(context.reference);
    }
    if (lowerText.match(/минулого\s*вечора/)) {
      return yesterdayEvening(context.reference);
    }
    if (lowerText.match(/наступної\s*ночі/)) {
      const daysToAdd = targetDate.getHours() < 22 ? 1 : 2;
      const nextDay = new Date(targetDate.getTime());
      nextDay.setDate(nextDay.getDate() + daysToAdd);
      assignSimilarDate(component, nextDay);
      component.imply("hour", 1);
    }
    if (lowerText.match(/цієї\s*ночі/)) {
      return midnight(context.reference);
    }
    if (lowerText.endsWith("опівночі") || lowerText.endsWith("вночі")) {
      return midnight(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKWeekdayParser.js
var PREFIX_GROUP8 = 1;
var WEEKDAY_GROUP8 = 2;
var POSTFIX_GROUP7 = 3;
var UKWeekdayParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(?:(?:,|\\(|（)\\s*)?(?:в\\s*?)?(?:у\\s*?)?(?:(цей|минулого|минулий|попередній|попереднього|наступного|наступний|наступному)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY8)})(?:\\s*(?:,|\\)|）))?(?:\\s*(на|у|в)\\s*(цьому|минулому|наступному)\\s*тижні)?`;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP8].toLocaleLowerCase();
    const weekday = WEEKDAY_DICTIONARY8[dayOfWeek];
    const prefix = match[PREFIX_GROUP8];
    const postfix = match[POSTFIX_GROUP7];
    let modifierWord = prefix || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLocaleLowerCase();
    let modifier = null;
    if (modifierWord == "минулого" || modifierWord == "минулий" || modifierWord == "попередній" || modifierWord == "попереднього") {
      modifier = "last";
    } else if (modifierWord == "наступного" || modifierWord == "наступний") {
      modifier = "next";
    } else if (modifierWord == "цей" || modifierWord == "цього" || modifierWord == "цьому") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKRelativeDateFormatParser.js
var MODIFIER_WORD_GROUP4 = 1;
var RELATIVE_WORD_GROUP4 = 2;
var UKRelativeDateFormatParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(в минулому|у минулому|на минулому|минулого|на наступному|в наступному|у наступному|наступного|на цьому|в цьому|у цьому|цього)\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY7)})(?=\\s*)`;
  }
  innerExtract(context, match) {
    const modifier = match[MODIFIER_WORD_GROUP4].toLowerCase();
    const unitWord = match[RELATIVE_WORD_GROUP4].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY7[unitWord];
    if (modifier == "на наступному" || modifier == "в наступному" || modifier == "у наступному" || modifier == "наступного") {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "на минулому" || modifier == "в минулому" || modifier == "у минулому" || modifier == "минулого") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = new Date(context.reference.instant.getTime());
    if (timeunit.match(/week/i)) {
      date.setDate(date.getDate() - date.getDay());
      components.imply("day", date.getDate());
      components.imply("month", date.getMonth() + 1);
      components.imply("year", date.getFullYear());
    } else if (timeunit.match(/month/i)) {
      date.setDate(1);
      components.imply("day", date.getDate());
      components.assign("year", date.getFullYear());
      components.assign("month", date.getMonth() + 1);
    } else if (timeunit.match(/year/i)) {
      date.setDate(1);
      date.setMonth(0);
      components.imply("day", date.getDate());
      components.imply("month", date.getMonth() + 1);
      components.assign("year", date.getFullYear());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKTimeUnitCasualRelativeFormatParser.js
var UKTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(ці|останні|минулі|майбутні|наступні|після|через|\\+|-)\\s*(${TIME_UNITS_PATTERN7})`;
  }
  innerExtract(context, match) {
    const prefix = match[1].toLowerCase();
    let timeUnits = parseDuration7(match[3]);
    switch (prefix) {
      case "останні":
      case "минулі":
      case "-":
        timeUnits = reverseDuration(timeUnits);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/index.js
var casual12 = new Chrono(createCasualConfiguration11());
var strict12 = new Chrono(createConfiguration11(true));
function createCasualConfiguration11() {
  const option = createConfiguration11(false);
  option.parsers.unshift(new UKCasualDateParser());
  option.parsers.unshift(new UKCasualTimeParser());
  option.parsers.unshift(new UkMonthNameParser());
  option.parsers.unshift(new UKRelativeDateFormatParser());
  option.parsers.unshift(new UKTimeUnitCasualRelativeFormatParser());
  return option;
}
function createConfiguration11(strictMode) {
  return includeCommonConfiguration({
    parsers: [
      new ISOFormatParser(),
      new SlashDateFormatParser(true),
      new UKTimeUnitWithinFormatParser(),
      new UKMonthNameLittleEndianParser(),
      new UKWeekdayParser(),
      new UKTimeExpressionParser(strictMode),
      new UKTimeUnitAgoFormatParser()
    ],
    refiners: [new UKMergeDateTimeRefiner(), new UKMergeDateRangeRefiner()]
  }, strictMode);
}
function parse12(text, ref, option) {
  return casual12.parse(text, ref, option);
}
function parseDate12(text, ref, option) {
  return casual12.parseDate(text, ref, option);
}

// node_modules/chrono-node/dist/esm/locales/it/index.js
var it_exports = {};
__export(it_exports, {
  GB: () => GB2,
  casual: () => casual13,
  createCasualConfiguration: () => createCasualConfiguration12,
  createConfiguration: () => createConfiguration12,
  parse: () => parse13,
  parseDate: () => parseDate13,
  strict: () => strict13
});

// node_modules/chrono-node/dist/esm/locales/it/constants.js
var WEEKDAY_DICTIONARY9 = {
  "domenica": 0,
  "dom": 0,
  "lunedì": 1,
  "lun": 1,
  "martedì": 2,
  "mar": 2,
  "mercoledì": 3,
  "merc": 3,
  "giovedì": 4,
  "giov": 4,
  "venerdì": 5,
  "ven": 5,
  "sabato": 6,
  "sab": 6
};
var FULL_MONTH_NAME_DICTIONARY4 = {};
var MONTH_DICTIONARY9 = {
  ...FULL_MONTH_NAME_DICTIONARY4,
  "gennaio": 1,
  "gen": 1,
  "gen.": 1,
  "febbraio": 2,
  "feb": 2,
  "feb.": 2,
  "febraio": 2,
  "febb": 2,
  "febb.": 2,
  "marzo": 3,
  "mar": 3,
  "mar.": 3,
  "aprile": 4,
  "apr": 4,
  "apr.": 4,
  "maggio": 5,
  "mag": 5,
  "giugno": 6,
  "giu": 6,
  "luglio": 7,
  "lug": 7,
  "lugl": 7,
  "lug.": 7,
  "agosto": 8,
  "ago": 8,
  "settembre": 9,
  "set": 9,
  "set.": 9,
  "sett": 9,
  "sett.": 9,
  "ottobre": 10,
  "ott": 10,
  "ott.": 10,
  "novembre": 11,
  "nov": 11,
  "nov.": 11,
  "dicembre": 12,
  "dic": 12,
  "dice": 12,
  "dic.": 12
};
var INTEGER_WORD_DICTIONARY8 = {
  "uno": 1,
  "due": 2,
  "tre": 3,
  "quattro": 4,
  "cinque": 5,
  "sei": 6,
  "sette": 7,
  "otto": 8,
  "nove": 9,
  "dieci": 10,
  "undici": 11,
  "dodici": 12
};
var ORDINAL_WORD_DICTIONARY5 = {
  "primo": 1,
  "secondo": 2,
  "terzo": 3,
  "quarto": 4,
  "quinto": 5,
  "sesto": 6,
  "settimo": 7,
  "ottavo": 8,
  "nono": 9,
  "decimo": 10,
  "undicesimo": 11,
  "dodicesimo": 12,
  "tredicesimo": 13,
  "quattordicesimo": 14,
  "quindicesimo": 15,
  "sedicesimo": 16,
  "diciassettesimo": 17,
  "diciottesimo": 18,
  "diciannovesimo": 19,
  "ventesimo": 20,
  "ventunesimo": 21,
  "ventiduesimo": 22,
  "ventitreesimo": 23,
  "ventiquattresimo": 24,
  "venticinquesimo": 25,
  "ventiseiesimo": 26,
  "ventisettesimo": 27,
  "ventottesimo": 28,
  "ventinovesimo": 29,
  "trentesimo": 30,
  "trentunesimo": 31
};
var TIME_UNIT_DICTIONARY8 = {
  "sec": "second",
  "secondo": "second",
  "secondi": "second",
  "min": "minute",
  "mins": "minute",
  "minuti": "minute",
  "h": "hour",
  "hr": "hour",
  "o": "hour",
  "ora": "hour",
  "ore": "hour",
  "giorno": "day",
  "giorni": "day",
  "settimana": "week",
  "settimane": "week",
  "mese": "month",
  "trimestre": "quarter",
  "trimestri": "quarter",
  "anni": "year",
  "anno": "year"
};
var NUMBER_PATTERN8 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY8)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}un?)?|un?\\b(?:\\s{0,2}qualcuno)?|qualcuno|molti|a?\\s{0,2}alcuni\\s{0,2}(?:of)?)`;
function parseNumberPattern8(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY8[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY8[num];
  } else if (num === "un" || num === "una") {
    return 1;
  } else if (num.match(/alcuni/)) {
    return 3;
  } else if (num.match(/metá/)) {
    return 0.5;
  } else if (num.match(/paio/)) {
    return 2;
  } else if (num.match(/molti/)) {
    return 7;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN6 = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY5)}|[0-9]{1,2}(?:mo|ndo|rzo|simo|esimo)?)`;
function parseOrdinalNumberPattern6(match) {
  let num = match.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY5[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY5[num];
  }
  num = num.replace(/(?:imo|ndo|rzo|rto|nto|sto|tavo|nono|cimo|timo|esimo)$/i, "");
  return parseInt(num);
}
var YEAR_PATTERN9 = `(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9])`;
function parseYear8(match) {
  if (/BE/i.test(match)) {
    match = match.replace(/BE/i, "");
    return parseInt(match) - 543;
  }
  if (/BCE?/i.test(match)) {
    match = match.replace(/BCE?/i, "");
    return -parseInt(match);
  }
  if (/(AD|CE)/i.test(match)) {
    match = match.replace(/(AD|CE)/i, "");
    return parseInt(match);
  }
  const rawYearNumber = parseInt(match);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN8 = `(${NUMBER_PATTERN8})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY8)})`;
var SINGLE_TIME_UNIT_REGEX8 = new RegExp(SINGLE_TIME_UNIT_PATTERN8, "i");
var TIME_UNITS_PATTERN8 = repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN8);
function parseDuration8(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX8.exec(remainingText);
  while (match) {
    collectDateTimeFragment8(fragments, match);
    remainingText = remainingText.substring(match[0].length).trim();
    match = SINGLE_TIME_UNIT_REGEX8.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment8(fragments, match) {
  const num = parseNumberPattern8(match[1]);
  const unit = TIME_UNIT_DICTIONARY8[match[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITTimeUnitWithinFormatParser.js
var PATTERN_WITH_PREFIX2 = new RegExp(`(?:within|in|for)\\s*(?:(?:più o meno|intorno|approssimativamente|verso|verso le)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN8})(?=\\W|$)`, "i");
var PATTERN_WITHOUT_PREFIX = new RegExp(`(?:(?:più o meno|intorno|approssimativamente|verso|verso le)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN8})(?=\\W|$)`, "i");
var ENTimeUnitWithinFormatParser2 = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return context.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX2;
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration8(match[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITMonthNameLittleEndianParser.js
var PATTERN46 = new RegExp(`(?:on\\s{0,3})?(${ORDINAL_NUMBER_PATTERN6})(?:\\s{0,3}(?:al|\\-|\\–|fino|alle|allo)?\\s{0,3}(${ORDINAL_NUMBER_PATTERN6}))?(?:-|/|\\s{0,3}(?:dal)?\\s{0,3})(${matchAnyPattern(MONTH_DICTIONARY9)})(?:(?:-|/|,?\\s{0,3})(${YEAR_PATTERN9}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
var DATE_GROUP12 = 1;
var DATE_TO_GROUP10 = 2;
var MONTH_NAME_GROUP16 = 3;
var YEAR_GROUP21 = 4;
var ENMonthNameLittleEndianParser2 = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN46;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY9[match[MONTH_NAME_GROUP16].toLowerCase()];
    const day = parseOrdinalNumberPattern6(match[DATE_GROUP12]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP12].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP21]) {
      const yearNumber = parseYear8(match[YEAR_GROUP21]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP10]) {
      const endDate = parseOrdinalNumberPattern6(match[DATE_TO_GROUP10]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITMonthNameMiddleEndianParser.js
var PATTERN47 = new RegExp(`(${matchAnyPattern(MONTH_DICTIONARY9)})(?:-|/|\\s*,?\\s*)(${ORDINAL_NUMBER_PATTERN6})(?!\\s*(?:am|pm))\\s*(?:(?:al|\\-|\\alle|\\del|\\s)\\s*(${ORDINAL_NUMBER_PATTERN6})\\s*)?(?:(?:-|/|\\s*,?\\s*)(${YEAR_PATTERN9}))?(?=\\W|$)(?!\\:\\d)`, "i");
var MONTH_NAME_GROUP17 = 1;
var DATE_GROUP13 = 2;
var DATE_TO_GROUP11 = 3;
var YEAR_GROUP22 = 4;
var ENMonthNameMiddleEndianParser2 = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN47;
  }
  innerExtract(context, match) {
    const month = MONTH_DICTIONARY9[match[MONTH_NAME_GROUP17].toLowerCase()];
    const day = parseOrdinalNumberPattern6(match[DATE_GROUP13]);
    if (day > 31) {
      return null;
    }
    const components = context.createParsingComponents({
      day,
      month
    });
    if (match[YEAR_GROUP22]) {
      const year3 = parseYear8(match[YEAR_GROUP22]);
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      components.imply("year", year3);
    }
    if (!match[DATE_TO_GROUP11]) {
      return components;
    }
    const endDate = parseOrdinalNumberPattern6(match[DATE_TO_GROUP11]);
    const result = context.createParsingResult(match.index, match[0]);
    result.start = components;
    result.end = components.clone();
    result.end.assign("day", endDate);
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITMonthNameParser.js
var PATTERN48 = new RegExp(`((?:in)\\s*)?(${matchAnyPattern(MONTH_DICTIONARY9)})\\s*(?:[,-]?\\s*(${YEAR_PATTERN9})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
var PREFIX_GROUP9 = 1;
var MONTH_NAME_GROUP18 = 2;
var YEAR_GROUP23 = 3;
var ENMonthNameParser2 = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN48;
  }
  innerExtract(context, match) {
    const monthName = match[MONTH_NAME_GROUP18].toLowerCase();
    if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY4[monthName]) {
      return null;
    }
    const result = context.createParsingResult(match.index + (match[PREFIX_GROUP9] || "").length, match.index + match[0].length);
    result.start.imply("day", 1);
    const month = MONTH_DICTIONARY9[monthName];
    result.start.assign("month", month);
    if (match[YEAR_GROUP23]) {
      const year3 = parseYear8(match[YEAR_GROUP23]);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, 1, month);
      result.start.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITCasualYearMonthDayParser.js
var PATTERN49 = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${matchAnyPattern(MONTH_DICTIONARY9)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
var YEAR_NUMBER_GROUP5 = 1;
var MONTH_NAME_GROUP19 = 2;
var MONTH_NUMBER_GROUP4 = 3;
var DATE_NUMBER_GROUP4 = 4;
var ENCasualYearMonthDayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN49;
  }
  innerExtract(context, match) {
    const month = match[MONTH_NUMBER_GROUP4] ? parseInt(match[MONTH_NUMBER_GROUP4]) : MONTH_DICTIONARY9[match[MONTH_NAME_GROUP19].toLowerCase()];
    if (month < 1 || month > 12) {
      return null;
    }
    const year3 = parseInt(match[YEAR_NUMBER_GROUP5]);
    const day = parseInt(match[DATE_NUMBER_GROUP4]);
    return {
      day,
      month,
      year: year3
    };
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITSlashMonthFormatParser.js
var PATTERN50 = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
var MONTH_GROUP7 = 1;
var YEAR_GROUP24 = 2;
var ENSlashMonthFormatParser2 = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN50;
  }
  innerExtract(context, match) {
    const year3 = parseInt(match[YEAR_GROUP24]);
    const month = parseInt(match[MONTH_GROUP7]);
    return context.createParsingComponents().imply("day", 1).assign("month", month).assign("year", year3);
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITTimeExpressionParser.js
var ENTimeExpressionParser2 = class extends AbstractTimeExpressionParser {
  constructor(strictMode) {
    super(strictMode);
  }
  followingPhase() {
    return "\\s*(?:\\-|\\–|\\~|\\〜|to|\\?)\\s*";
  }
  primaryPrefix() {
    return "(?:(?:alle|dalle)\\s*)??";
  }
  primarySuffix() {
    return "(?:\\s*(?:o\\W*in punto|alle\\s*sera|in\\s*del\\s*(?:mattina|pomeriggio)))?(?!/)(?=\\W|$)";
  }
  extractPrimaryTimeComponents(context, match) {
    const components = super.extractPrimaryTimeComponents(context, match);
    if (components) {
      if (match[0].endsWith("sera")) {
        const hour = components.get("hour");
        if (hour >= 6 && hour < 12) {
          components.assign("hour", components.get("hour") + 12);
          components.assign("meridiem", Meridiem.PM);
        } else if (hour < 6) {
          components.assign("meridiem", Meridiem.AM);
        }
      }
      if (match[0].endsWith("pomeriggio")) {
        components.assign("meridiem", Meridiem.PM);
        const hour = components.get("hour");
        if (hour >= 0 && hour <= 6) {
          components.assign("hour", components.get("hour") + 12);
        }
      }
      if (match[0].endsWith("mattina")) {
        components.assign("meridiem", Meridiem.AM);
        const hour = components.get("hour");
        if (hour < 12) {
          components.assign("hour", components.get("hour"));
        }
      }
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITTimeUnitAgoFormatParser.js
var PATTERN51 = new RegExp(`(${TIME_UNITS_PATTERN8})\\s{0,5}(?:fa|prima|precedente)(?=(?:\\W|$))`, "i");
var STRICT_PATTERN5 = new RegExp(`(${TIME_UNITS_PATTERN8})\\s{0,5}fa(?=(?:\\W|$))`, "i");
var ENTimeUnitAgoFormatParser2 = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMode) {
    super();
    __publicField(this, "strictMode");
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN5 : PATTERN51;
  }
  innerExtract(context, match) {
    const timeUnits = parseDuration8(match[1]);
    const outputTimeUnits = reverseDuration(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITTimeUnitLaterFormatParser.js
var PATTERN52 = new RegExp(`(${TIME_UNITS_PATTERN8})\\s{0,5}(?:dopo|più tardi|da adesso|avanti|oltre|a seguire)(?=(?:\\W|$))`, "i");
var STRICT_PATTERN6 = new RegExp("(" + TIME_UNITS_PATTERN8 + ")(dopo|più tardi)(?=(?:\\W|$))", "i");
var GROUP_NUM_TIMEUNITS3 = 1;
var ENTimeUnitLaterFormatParser2 = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMode) {
    super();
    __publicField(this, "strictMode");
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN6 : PATTERN52;
  }
  innerExtract(context, match) {
    const fragments = parseDuration8(match[GROUP_NUM_TIMEUNITS3]);
    return ParsingComponents.createRelativeFromReference(context.reference, fragments);
  }
};

// node_modules/chrono-node/dist/esm/locales/it/refiners/ITMergeDateRangeRefiner.js
var ENMergeDateRangeRefiner2 = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(to|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/it/refiners/ITMergeDateTimeRefiner.js
var ENMergeDateTimeRefiner2 = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(T|alle|dopo|prima|il|di|del|delle|,|-)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITCasualDateParser.js
var PATTERN53 = /(ora|oggi|stasera|questa sera|domani|dmn|ieri\s*sera)(?=\W|$)/i;
var ITCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return PATTERN53;
  }
  innerExtract(context, match) {
    let targetDate = context.refDate;
    const lowerText = match[0].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "ora":
        return now(context.reference);
      case "oggi":
        return today(context.reference);
      case "ieri":
        return yesterday(context.reference);
      case "domani":
      case "dmn":
        return tomorrow(context.reference);
      case "stasera":
      case "questa sera":
        return tonight(context.reference);
      default:
        if (lowerText.match(/ieri\s*sera/)) {
          if (targetDate.getHours() > 6) {
            const previousDay = new Date(targetDate.getTime());
            previousDay.setDate(previousDay.getDate() - 1);
            targetDate = previousDay;
          }
          assignSimilarDate(component, targetDate);
          component.imply("hour", 0);
        }
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITCasualTimeParser.js
var PATTERN54 = /(?:questo|questa)?\s{0,3}(mattina|pomeriggio|sera|notte|mezzanotte|mezzogiorno)(?=\W|$)/i;
var ITCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN54;
  }
  innerExtract(context, match) {
    const targetDate = context.refDate;
    const component = context.createParsingComponents();
    switch (match[1].toLowerCase()) {
      case "pomeriggio":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 15);
        break;
      case "sera":
      case "notte":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 20);
        break;
      case "mezzanotte":
        const nextDay = new Date(targetDate.getTime());
        nextDay.setDate(nextDay.getDate() + 1);
        assignSimilarDate(component, nextDay);
        implySimilarTime(component, nextDay);
        component.imply("hour", 0);
        component.imply("minute", 0);
        component.imply("second", 0);
        break;
      case "mattina":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 6);
        break;
      case "mezzogiorno":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 12);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITWeekdayParser.js
var PATTERN55 = new RegExp(`(?:(?:\\,|\\(|\\（)\\s*)?(?:il\\s*?)?(?:(questa|l'ultima|scorsa|prossima)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY9)})(?:\\s*(?:\\,|\\)|\\）))?(?:\\s*(questa|l'ultima|scorsa|prossima)\\s*settimana)?(?=\\W|$)`, "i");
var PREFIX_GROUP10 = 1;
var WEEKDAY_GROUP9 = 2;
var POSTFIX_GROUP8 = 3;
var ITWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN55;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP9].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY9[dayOfWeek];
    const prefix = match[PREFIX_GROUP10];
    const postfix = match[POSTFIX_GROUP8];
    let modifierWord = prefix || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord == "ultima" || modifierWord == "scorsa") {
      modifier = "ultima";
    } else if (modifierWord == "prossima") {
      modifier = "prossima";
    } else if (modifierWord == "questa") {
      modifier = "questa";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITRelativeDateFormatParser.js
var PATTERN56 = new RegExp(`(questo|ultimo|scorso|prossimo|dopo\\s*questo|questa|ultima|scorsa|prossima\\s*questa)\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY8)})(?=\\s*)(?=\\W|$)`, "i");
var MODIFIER_WORD_GROUP5 = 1;
var RELATIVE_WORD_GROUP5 = 2;
var ITRelativeDateFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN56;
  }
  innerExtract(context, match) {
    const modifier = match[MODIFIER_WORD_GROUP5].toLowerCase();
    const unitWord = match[RELATIVE_WORD_GROUP5].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY8[unitWord];
    if (modifier == "prossimo" || modifier.startsWith("dopo")) {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "prima" || modifier == "precedente") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = new Date(context.reference.instant.getTime());
    if (unitWord.match(/settimana/i)) {
      date.setDate(date.getDate() - date.getDay());
      components.imply("day", date.getDate());
      components.imply("month", date.getMonth() + 1);
      components.imply("year", date.getFullYear());
    } else if (unitWord.match(/mese/i)) {
      date.setDate(1);
      components.imply("day", date.getDate());
      components.assign("year", date.getFullYear());
      components.assign("month", date.getMonth() + 1);
    } else if (unitWord.match(/anno/i)) {
      date.setDate(1);
      date.setMonth(0);
      components.imply("day", date.getDate());
      components.imply("month", date.getMonth() + 1);
      components.assign("year", date.getFullYear());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/it/parsers/ITTimeUnitCasualRelativeFormatParser.js
var PATTERN57 = new RegExp(`(questo|ultimo|passato|prossimo|dopo|questa|ultima|passata|prossima|\\+|-)\\s*(${TIME_UNITS_PATTERN8})(?=\\W|$)`, "i");
var ENTimeUnitCasualRelativeFormatParser2 = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN57;
  }
  innerExtract(context, match) {
    const prefix = match[1].toLowerCase();
    let timeUnits = parseDuration8(match[2]);
    switch (prefix) {
      case "last":
      case "past":
      case "-":
        timeUnits = reverseDuration(timeUnits);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/it/refiners/ITMergeRelativeDateRefiner.js
function hasImpliedEarlierReferenceDate2(result) {
  return result.text.match(/\s+(prima|dal)$/i) != null;
}
function hasImpliedLaterReferenceDate2(result) {
  return result.text.match(/\s+(dopo|dal|fino)$/i) != null;
}
var ENMergeRelativeDateRefiner = class extends MergingRefiner {
  patternBetween() {
    return /^\s*$/i;
  }
  shouldMergeResults(textBetween, currentResult, nextResult) {
    if (!textBetween.match(this.patternBetween())) {
      return false;
    }
    if (!hasImpliedEarlierReferenceDate2(currentResult) && !hasImpliedLaterReferenceDate2(currentResult)) {
      return false;
    }
    return !!nextResult.start.get("day") && !!nextResult.start.get("month") && !!nextResult.start.get("year");
  }
  mergeResults(textBetween, currentResult, nextResult) {
    let timeUnits = parseDuration8(currentResult.text);
    if (hasImpliedEarlierReferenceDate2(currentResult)) {
      timeUnits = reverseDuration(timeUnits);
    }
    const components = ParsingComponents.createRelativeFromReference(ReferenceWithTimezone.fromDate(nextResult.start.date()), timeUnits);
    return new ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
  }
};

// node_modules/chrono-node/dist/esm/locales/it/index.js
var casual13 = new Chrono(createCasualConfiguration12(false));
var strict13 = new Chrono(createConfiguration12(true, false));
var GB2 = new Chrono(createConfiguration12(false, true));
function parse13(text, ref, option) {
  return casual13.parse(text, ref, option);
}
function parseDate13(text, ref, option) {
  return casual13.parseDate(text, ref, option);
}
function createCasualConfiguration12(littleEndian = false) {
  const option = createConfiguration12(false, littleEndian);
  option.parsers.unshift(new ITCasualDateParser());
  option.parsers.unshift(new ITCasualTimeParser());
  option.parsers.unshift(new ENMonthNameParser2());
  option.parsers.unshift(new ITRelativeDateFormatParser());
  option.parsers.unshift(new ENTimeUnitCasualRelativeFormatParser2());
  return option;
}
function createConfiguration12(strictMode = true, littleEndian = false) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(littleEndian),
      new ENTimeUnitWithinFormatParser2(),
      new ENMonthNameLittleEndianParser2(),
      new ENMonthNameMiddleEndianParser2(),
      new ITWeekdayParser(),
      new ENCasualYearMonthDayParser(),
      new ENSlashMonthFormatParser2(),
      new ENTimeExpressionParser2(strictMode),
      new ENTimeUnitAgoFormatParser2(strictMode),
      new ENTimeUnitLaterFormatParser2(strictMode)
    ],
    refiners: [new ENMergeRelativeDateRefiner(), new ENMergeDateTimeRefiner2(), new ENMergeDateRangeRefiner2()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/sv/index.js
var sv_exports = {};
__export(sv_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual14,
  createCasualConfiguration: () => createCasualConfiguration13,
  createConfiguration: () => createConfiguration13,
  parse: () => parse14,
  parseDate: () => parseDate14,
  strict: () => strict14
});

// node_modules/chrono-node/dist/esm/locales/sv/constants.js
var WEEKDAY_DICTIONARY10 = {
  "söndag": 0,
  "sön": 0,
  "so": 0,
  "måndag": 1,
  "mån": 1,
  "må": 1,
  "tisdag": 2,
  "tis": 2,
  "ti": 2,
  "onsdag": 3,
  "ons": 3,
  "on": 3,
  "torsdag": 4,
  "tors": 4,
  "to": 4,
  "fredag": 5,
  "fre": 5,
  "fr": 5,
  "lördag": 6,
  "lör": 6,
  "lö": 6
};
var MONTH_DICTIONARY10 = {
  "januari": 1,
  "jan": 1,
  "jan.": 1,
  "februari": 2,
  "feb": 2,
  "feb.": 2,
  "mars": 3,
  "mar": 3,
  "mar.": 3,
  "april": 4,
  "apr": 4,
  "apr.": 4,
  "maj": 5,
  "juni": 6,
  "jun": 6,
  "jun.": 6,
  "juli": 7,
  "jul": 7,
  "jul.": 7,
  "augusti": 8,
  "aug": 8,
  "aug.": 8,
  "september": 9,
  "sep": 9,
  "sep.": 9,
  "sept": 9,
  "oktober": 10,
  "okt": 10,
  "okt.": 10,
  "november": 11,
  "nov": 11,
  "nov.": 11,
  "december": 12,
  "dec": 12,
  "dec.": 12
};
var ORDINAL_NUMBER_DICTIONARY = {
  "första": 1,
  "andra": 2,
  "tredje": 3,
  "fjärde": 4,
  "femte": 5,
  "sjätte": 6,
  "sjunde": 7,
  "åttonde": 8,
  "nionde": 9,
  "tionde": 10,
  "elfte": 11,
  "tolfte": 12,
  "trettonde": 13,
  "fjortonde": 14,
  "femtonde": 15,
  "sextonde": 16,
  "sjuttonde": 17,
  "artonde": 18,
  "nittonde": 19,
  "tjugonde": 20,
  "tjugoförsta": 21,
  "tjugoandra": 22,
  "tjugotredje": 23,
  "tjugofjärde": 24,
  "tjugofemte": 25,
  "tjugosjätte": 26,
  "tjugosjunde": 27,
  "tjugoåttonde": 28,
  "tjugonionde": 29,
  "trettionde": 30,
  "trettioförsta": 31
};
var INTEGER_WORD_DICTIONARY9 = {
  "en": 1,
  "ett": 1,
  "två": 2,
  "tre": 3,
  "fyra": 4,
  "fem": 5,
  "sex": 6,
  "sju": 7,
  "åtta": 8,
  "nio": 9,
  "tio": 10,
  "elva": 11,
  "tolv": 12,
  "tretton": 13,
  "fjorton": 14,
  "femton": 15,
  "sexton": 16,
  "sjutton": 17,
  "arton": 18,
  "nitton": 19,
  "tjugo": 20,
  "trettiо": 30,
  "fyrtio": 40,
  "femtio": 50,
  "sextio": 60,
  "sjuttio": 70,
  "åttio": 80,
  "nittio": 90,
  "hundra": 100,
  "tusen": 1e3
};
var TIME_UNIT_DICTIONARY9 = {
  "sek": "second",
  "sekund": "second",
  "sekunder": "second",
  "min": "minute",
  "minut": "minute",
  "minuter": "minute",
  "tim": "hour",
  "timme": "hour",
  "timmar": "hour",
  "dag": "day",
  "dagar": "day",
  "vecka": "week",
  "veckor": "week",
  "mån": "month",
  "månad": "month",
  "månader": "month",
  "år": "year",
  "kvartаl": "quarter",
  "kvartal": "quarter"
};
var TIME_UNIT_NO_ABBR_DICTIONARY = {
  "sekund": "second",
  "sekunder": "second",
  "minut": "minute",
  "minuter": "minute",
  "timme": "hour",
  "timmar": "hour",
  "dag": "day",
  "dagar": "day",
  "vecka": "week",
  "veckor": "week",
  "månad": "month",
  "månader": "month",
  "år": "year",
  "kvartal": "quarter"
};
function parseDuration9(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match = SINGLE_TIME_UNIT_REGEX9.exec(remainingText);
  while (match) {
    collectDateTimeFragment9(fragments, match);
    remainingText = remainingText.substring(match[0].length);
    match = SINGLE_TIME_UNIT_REGEX9.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment9(fragments, match) {
  const num = parseNumberPattern9(match[1]);
  const unit = TIME_UNIT_DICTIONARY9[match[2].toLowerCase()];
  fragments[unit] = num;
}
var NUMBER_PATTERN9 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY9)}|\\d+)`;
var ORDINAL_NUMBER_PATTERN7 = `(?:${matchAnyPattern(ORDINAL_NUMBER_DICTIONARY)}|\\d{1,2}(?:e|:e))`;
var TIME_UNIT_PATTERN = `(?:${matchAnyPattern(TIME_UNIT_DICTIONARY9)})`;
var SINGLE_TIME_UNIT_PATTERN9 = `(${NUMBER_PATTERN9})\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY9)})\\s{0,5}`;
var SINGLE_TIME_UNIT_REGEX9 = new RegExp(SINGLE_TIME_UNIT_PATTERN9, "i");
var SINGLE_TIME_UNIT_NO_ABBR_PATTERN2 = `(${NUMBER_PATTERN9})\\s{0,5}(${matchAnyPattern(TIME_UNIT_NO_ABBR_DICTIONARY)})\\s{0,5}`;
var TIME_UNITS_PATTERN9 = repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN9);
var TIME_UNITS_NO_ABBR_PATTERN2 = repeatedTimeunitPattern("", SINGLE_TIME_UNIT_NO_ABBR_PATTERN2);
function parseNumberPattern9(match) {
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY9[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY9[num];
  }
  return parseInt(num);
}
function parseYear9(match) {
  if (/\d+/.test(match)) {
    let yearNumber = parseInt(match);
    if (yearNumber < 100) {
      yearNumber = findMostLikelyADYear(yearNumber);
    }
    return yearNumber;
  }
  const num = match.toLowerCase();
  if (INTEGER_WORD_DICTIONARY9[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY9[num];
  }
  return parseInt(match);
}

// node_modules/chrono-node/dist/esm/locales/sv/parsers/SVWeekdayParser.js
var PATTERN58 = new RegExp(`(?:(?:\\,|\\(|\\（)\\s*)?(?:på\\s*?)?(?:(förra|senaste|nästa|kommande)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY10)})(?:\\s*(?:\\,|\\)|\\）))?(?:\\s*(förra|senaste|nästa|kommande)\\s*vecka)?(?=\\W|$)`, "i");
var PREFIX_GROUP11 = 1;
var SUFFIX_GROUP2 = 3;
var WEEKDAY_GROUP10 = 2;
var SVWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN58;
  }
  innerExtract(context, match) {
    const dayOfWeek = match[WEEKDAY_GROUP10].toLowerCase();
    const offset = WEEKDAY_DICTIONARY10[dayOfWeek];
    const prefix = match[PREFIX_GROUP11];
    const postfix = match[SUFFIX_GROUP2];
    let modifierWord = prefix || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord.match(/förra|senaste/)) {
      modifier = "last";
    } else if (modifierWord.match(/nästa|kommande/)) {
      modifier = "next";
    }
    return createParsingComponentsAtWeekday(context.reference, offset, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/sv/parsers/SVMonthNameLittleEndianParser.js
var PATTERN59 = new RegExp(`(?:den\\s*?)?([0-9]{1,2})(?:\\s*(?:till|\\-|\\–|\\s)\\s*([0-9]{1,2}))?\\s*(${matchAnyPattern(MONTH_DICTIONARY10)})(?:(?:-|/|,?\\s*)([0-9]{4}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
var DATE_GROUP14 = 1;
var DATE_TO_GROUP12 = 2;
var MONTH_NAME_GROUP20 = 3;
var YEAR_GROUP25 = 4;
var SVMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN59;
  }
  innerExtract(context, match) {
    const result = context.createParsingResult(match.index, match[0]);
    const month = MONTH_DICTIONARY10[match[MONTH_NAME_GROUP20].toLowerCase()];
    const day = parseInt(match[DATE_GROUP14]);
    if (day > 31) {
      match.index = match.index + match[DATE_GROUP14].length;
      return null;
    }
    result.start.assign("month", month);
    result.start.assign("day", day);
    if (match[YEAR_GROUP25]) {
      const yearNumber = parseYear9(match[YEAR_GROUP25]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month);
      result.start.imply("year", year3);
    }
    if (match[DATE_TO_GROUP12]) {
      const endDate = parseInt(match[DATE_TO_GROUP12]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/sv/parsers/SVTimeUnitCasualRelativeFormatParser.js
var PATTERN60 = new RegExp(`(denna|den här|förra|passerade|nästa|kommande|efter|\\+|-)\\s*(${TIME_UNITS_PATTERN9})(?=\\W|$)`, "i");
var PATTERN_NO_ABBR2 = new RegExp(`(denna|den här|förra|passerade|nästa|kommande|efter|\\+|-)\\s*(${TIME_UNITS_NO_ABBR_PATTERN2})(?=\\W|$)`, "i");
var SVTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(allowAbbreviations = true) {
    super();
    __publicField(this, "allowAbbreviations");
    this.allowAbbreviations = allowAbbreviations;
  }
  innerPattern() {
    return this.allowAbbreviations ? PATTERN60 : PATTERN_NO_ABBR2;
  }
  innerExtract(context, match) {
    const prefix = match[1].toLowerCase();
    let duration = parseDuration9(match[2]);
    if (!duration) {
      return null;
    }
    switch (prefix) {
      case "förra":
      case "passerade":
      case "-":
        duration = reverseDuration(duration);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, duration);
  }
};

// node_modules/chrono-node/dist/esm/locales/sv/parsers/SVCasualDateParser.js
var PATTERN61 = new RegExp(`(nu|idag|imorgon|övermorgon|igår|förrgår|i\\s*förrgår)(?:\\s*(?:på\\s*)?(morgonen?|förmiddagen?|middagen?|eftermiddagen?|kvällen?|natten?|midnatt))?(?=\\W|$)`, "i");
var DATE_GROUP15 = 1;
var TIME_GROUP2 = 2;
var SVCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return PATTERN61;
  }
  innerExtract(context, match) {
    const targetDate = context.refDate;
    const dateKeyword = (match[DATE_GROUP15] || "").toLowerCase();
    const timeKeyword = (match[TIME_GROUP2] || "").toLowerCase();
    let component = context.createParsingComponents();
    switch (dateKeyword) {
      case "nu":
        component = now(context.reference);
        break;
      case "idag":
        component = today(context.reference);
        break;
      case "imorgon":
      case "imorn":
        const nextDay = new Date(targetDate.getTime());
        nextDay.setDate(nextDay.getDate() + 1);
        assignSimilarDate(component, nextDay);
        implySimilarTime(component, nextDay);
        break;
      case "igår":
        const previousDay = new Date(targetDate.getTime());
        previousDay.setDate(previousDay.getDate() - 1);
        assignSimilarDate(component, previousDay);
        implySimilarTime(component, previousDay);
        break;
      case "förrgår":
      case "i förrgår":
        const twoDaysAgo = new Date(targetDate.getTime());
        twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
        assignSimilarDate(component, twoDaysAgo);
        implySimilarTime(component, twoDaysAgo);
        break;
    }
    switch (timeKeyword) {
      case "morgon":
      case "morgonen":
        component.imply("hour", 6);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("millisecond", 0);
        break;
      case "förmiddag":
      case "förmiddagen":
        component.imply("hour", 9);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("millisecond", 0);
        break;
      case "middag":
      case "middagen":
        component.imply("hour", 12);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("millisecond", 0);
        break;
      case "eftermiddag":
      case "eftermiddagen":
        component.imply("hour", 15);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("millisecond", 0);
        break;
      case "kväll":
      case "kvällen":
        component.imply("hour", 20);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("millisecond", 0);
        break;
      case "natt":
      case "natten":
      case "midnatt":
        if (timeKeyword === "midnatt") {
          component.imply("hour", 0);
        } else {
          component.imply("hour", 2);
        }
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("millisecond", 0);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/sv/index.js
var casual14 = new Chrono(createCasualConfiguration13());
var strict14 = new Chrono(createConfiguration13(true));
function parse14(text, ref, option) {
  return casual14.parse(text, ref, option);
}
function parseDate14(text, ref, option) {
  return casual14.parseDate(text, ref, option);
}
function createCasualConfiguration13(littleEndian = true) {
  const option = createConfiguration13(false, littleEndian);
  option.parsers.unshift(new SVCasualDateParser());
  return option;
}
function createConfiguration13(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new ISOFormatParser(),
      new SlashDateFormatParser(littleEndian),
      new SVMonthNameLittleEndianParser(),
      new SVWeekdayParser(),
      new SVTimeUnitCasualRelativeFormatParser()
    ],
    refiners: []
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/index.js
var strict15 = strict;
var casual15 = casual;
function parse15(text, ref, option) {
  return casual15.parse(text, ref, option);
}
function parseDate15(text, ref, option) {
  return casual15.parseDate(text, ref, option);
}
export {
  Chrono,
  Meridiem,
  ParsingComponents,
  ParsingContext,
  ParsingResult,
  ReferenceWithTimezone,
  Weekday,
  casual15 as casual,
  de_exports as de,
  en_exports as en,
  es_exports as es,
  fr_exports as fr,
  it_exports as it,
  ja_exports as ja,
  nl_exports as nl,
  parse15 as parse,
  parseDate15 as parseDate,
  pt_exports as pt,
  ru_exports as ru,
  strict15 as strict,
  sv_exports as sv,
  uk_exports as uk,
  zh_exports as zh
};
//# sourceMappingURL=chrono-node.js.map
